<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - public/scripts/emperor_required_resources/js/d3.parcoords.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>public/scripts/emperor_required_resources/js/d3.parcoords.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.08</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">568</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">88.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">d3.parcoords = function(config) {
  var __ = {
    data: [],
    dimensions: [],
    types: {},
    brushed: false,
    mode: &quot;default&quot;,
    rate: 20,
    width: 600,
    height: 300,
    margin: { top: 24, right: 0, bottom: 12, left: 0 },
    color: &quot;#069&quot;,
    composite: &quot;source-over&quot;,
    alpha: 0.7
  };

  extend(__, config);
var pc = function(selection) {
  selection = pc.selection = d3.select(selection);

  __.width = selection[0][0].clientWidth;
  __.height = selection[0][0].clientHeight;

  // canvas data layers
  [&quot;shadows&quot;, &quot;marks&quot;, &quot;foreground&quot;, &quot;highlight&quot;].forEach(function(layer) {
    canvas[layer] = selection
      .append(&quot;canvas&quot;)
      .attr(&quot;class&quot;, layer)[0][0];
    ctx[layer] = canvas[layer].getContext(&quot;2d&quot;);
  });

  // svg tick and brush layers
  pc.svg = selection
    .append(&quot;svg&quot;)
      .attr(&quot;width&quot;, __.width)
      .attr(&quot;height&quot;, __.height)
    .append(&quot;svg:g&quot;)
      .attr(&quot;transform&quot;, &quot;translate(&quot; + __.margin.left + &quot;,&quot; + __.margin.top + &quot;)&quot;);

  return pc;
};
var events = d3.dispatch.apply(this,[&quot;render&quot;, &quot;resize&quot;, &quot;highlight&quot;, &quot;brush&quot;].concat(d3.keys(__))),
    w = function() { return __.width - __.margin.right - __.margin.left; },
    h = function() { return __.height - __.margin.top - __.margin.bottom },
    flags = {
      brushable: false,
      reorderable: false,
      axes: false,
      interactive: false,
      shadows: false,
      debug: false
    },
    xscale = d3.scale.ordinal(),
    yscale = {},
    dragging = {},
    line = d3.svg.line(),
    axis = d3.svg.axis().orient(&quot;left&quot;).ticks(5),
    g, // groups for axes, brushes
    ctx = {},
    canvas = {};

// side effects for setters
var side_effects = d3.dispatch.apply(this,d3.keys(__))
  .on(&quot;composite&quot;, function(d) { ctx.foreground.globalCompositeOperation = d.value; })
  .on(&quot;alpha&quot;, function(d) { ctx.foreground.globalAlpha = d.value; })
  .on(&quot;width&quot;, function(d) { pc.resize(); })
  .on(&quot;height&quot;, function(d) { pc.resize(); })
  .on(&quot;margin&quot;, function(d) { pc.resize(); })
  .on(&quot;rate&quot;, function(d) { rqueue.rate(d.value); })
  .on(&quot;data&quot;, function(d) {
    if (flags.shadows) paths(__.data, ctx.shadows);
  })
  .on(&quot;dimensions&quot;, function(d) {
    xscale.domain(__.dimensions);
    if (flags.interactive) pc.render().updateAxes();
  });

// expose the state of the chart
pc.state = __;
pc.flags = flags;

// create getter/setters
getset(pc, __, events);

// expose events
d3.rebind(pc, events, &quot;on&quot;);

// tick formatting
d3.rebind(pc, axis, &quot;ticks&quot;, &quot;orient&quot;, &quot;tickValues&quot;, &quot;tickSubdivide&quot;, &quot;tickSize&quot;, &quot;tickPadding&quot;, &quot;tickFormat&quot;);

// getter/setter with event firing
function getset(obj,state,events)  {
  d3.keys(state).forEach(function(key) {
    obj[key] = function(x) {
      if (!arguments.length) return state[key];
      var old = state[key];
      state[key] = x;
      side_effects[key].call(pc,{&quot;value&quot;: x, &quot;previous&quot;: old});
      events[key].call(pc,{&quot;value&quot;: x, &quot;previous&quot;: old});
      return obj;
    };
  });
};

function extend(target, source) {
  for (key in source) {
    target[key] = source[key];
  }
  return target;
};
pc.autoscale = function() {
  // yscale
  var defaultScales = {
    &quot;number&quot;: function(k) {
      return d3.scale.linear()
        .domain(d3.extent(__.data, function(d) { return +d[k]; }))
        .range([h()+1, 1])
    },
    &quot;string&quot;: function(k) {
      return d3.scale.ordinal()
        .domain(__.data.map(function(p) { return p[k]; }))
        .rangePoints([h()+1, 1])
    }
  };

  __.dimensions.forEach(function(k) {
    yscale[k] = defaultScales[__.types[k]](k);
  });

  // hack to remove ordinal dimensions with many values
  pc.dimensions(pc.dimensions().filter(function(p,i) {
    var uniques = yscale[p].domain().length;
    if (__.types[p] == &quot;string&quot; &amp;&amp; (uniques &gt; 60 || uniques &lt; 2)) {
      return false;
    }
    return true;
  }));

  // xscale
  xscale.rangePoints([0, w()], 1);

  // canvas sizes
  pc.selection.selectAll(&quot;canvas&quot;)
      .style(&quot;margin-top&quot;, __.margin.top + &quot;px&quot;)
      .style(&quot;margin-left&quot;, __.margin.left + &quot;px&quot;)
      .attr(&quot;width&quot;, w()+2)
      .attr(&quot;height&quot;, h()+2)

  // default styles, needs to be set when canvas width changes
  ctx.foreground.strokeStyle = __.color;
  ctx.foreground.lineWidth = 1.4;
  ctx.foreground.globalCompositeOperation = __.composite;
  ctx.foreground.globalAlpha = __.alpha;
  ctx.highlight.lineWidth = 3;
  ctx.shadows.strokeStyle = &quot;#dadada&quot;;

  return this;
};
pc.detectDimensions = function() {
  pc.types(pc.detectDimensionTypes(__.data));
  pc.dimensions(d3.keys(pc.types()));
  return this;
};

// a better &quot;typeof&quot; from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable
pc.toType = function(v) {
  return ({}).toString.call(v).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
};

// try to coerce to number before returning type
pc.toTypeCoerceNumbers = function(v) {
  if ((parseFloat(v) == v) &amp;&amp; (v != null)) return &quot;number&quot;;
  return pc.toType(v);
};

// attempt to determine types of each dimension based on first row of data
pc.detectDimensionTypes = function(data) {
  var types = {}
  d3.keys(data[0])
    .forEach(function(col) {
      types[col] = pc.toTypeCoerceNumbers(data[0][col]);
    });
  return types;
};
pc.render = function() {
  // try to autodetect dimensions and create scales
  if (!__.dimensions.length) pc.detectDimensions();
  if (!(__.dimensions[0] in yscale)) pc.autoscale();

  pc.render[__.mode]();

  events.render.call(this);
  return this;
};

pc.render.default = function() {
  pc.clear(&#039;foreground&#039;);
  if (__.brushed) {
    __.brushed.forEach(path_foreground);
  } else {
    __.data.forEach(path_foreground);
  }
};

var rqueue = d3.renderQueue(path_foreground)
  .rate(50)
  .clear(function() { pc.clear(&#039;foreground&#039;); });

pc.render.queue = function() {
  if (__.brushed) {
    rqueue(__.brushed);
  } else {
    rqueue(__.data);
  }
};
pc.shadows = function() {
  flags.shadows = true;
  if (__.data.length &gt; 0) paths(__.data, ctx.shadows);
  return this;
};

// draw little dots on the axis line where data intersects
pc.axisDots = function() {
  var ctx = pc.ctx.marks;
  ctx.globalAlpha = d3.min([1/Math.pow(data.length, 1/2), 1]);
  __.data.forEach(function(d) {
    __.dimensions.map(function(p,i) {
      ctx.fillRect(position(p)-0.75,yscale[p](d[p])-0.75,1.5,1.5);
    });
  });
  return this;
};

// draw single polyline
function color_path(d, ctx) {
  ctx.strokeStyle = d3.functor(__.color)(d);
  ctx.beginPath();
  __.dimensions.map(function(p,i) {
    if (i == 0) {
      ctx.moveTo(position(p),yscale[p](d[p]));
    } else {
      ctx.lineTo(position(p),yscale[p](d[p]));
    }
  });
  ctx.stroke();
};

// draw many polylines of the same color
function paths(data, ctx) {
  ctx.clearRect(-1,-1,w()+2,h()+2);
  ctx.beginPath();
  data.forEach(function(d) {
    __.dimensions.map(function(p,i) {
      if (i == 0) {
        ctx.moveTo(position(p),yscale[p](d[p]));
      } else {
        ctx.lineTo(position(p),yscale[p](d[p]));
      }
    });
  });
  ctx.stroke();
};

function path_foreground(d) {
  return color_path(d, ctx.foreground);
};

function path_highlight(d) {
  return color_path(d, ctx.highlight);
};
pc.clear = function(layer) {
  ctx[layer].clearRect(0,0,w()+2,h()+2);
  return this;
};
pc.createAxes = function() {
  if (g) pc.removeAxes();

  // Add a group element for each dimension.
  g = pc.svg.selectAll(&quot;.dimension&quot;)
      .data(__.dimensions, function(d) { return d; })
    .enter().append(&quot;svg:g&quot;)
      .attr(&quot;class&quot;, &quot;dimension&quot;)
      .attr(&quot;transform&quot;, function(d) { return &quot;translate(&quot; + xscale(d) + &quot;)&quot;; })

  // Add an axis and title.
  g.append(&quot;svg:g&quot;)
      .attr(&quot;class&quot;, &quot;axis&quot;)
      .attr(&quot;transform&quot;, &quot;translate(0,0)&quot;)
      .each(function(d) { d3.select(this).call(axis.scale(yscale[d])); })
    .append(&quot;svg:text&quot;)
      .attr({
        &quot;text-anchor&quot;: &quot;middle&quot;,
        &quot;y&quot;: 0,
        &quot;transform&quot;: &quot;translate(0,-12)&quot;,
        &quot;x&quot;: 0,
        &quot;class&quot;: &quot;label&quot;
      })
      .text(String)

  flags.axes= true;
  return this;
};

pc.removeAxes = function() {
  g.remove();
  return this;
};

pc.updateAxes = function() {
  var g_data = pc.svg.selectAll(&quot;.dimension&quot;)
      .data(__.dimensions, function(d) { return d; })

  g_data.enter().append(&quot;svg:g&quot;)
      .attr(&quot;class&quot;, &quot;dimension&quot;)
      .attr(&quot;transform&quot;, function(p) { return &quot;translate(&quot; + position(p) + &quot;)&quot;; })
      .style(&quot;opacity&quot;, 0)
      .append(&quot;svg:g&quot;)
      .attr(&quot;class&quot;, &quot;axis&quot;)
      .attr(&quot;transform&quot;, &quot;translate(0,0)&quot;)
      .each(function(d) { d3.select(this).call(axis.scale(yscale[d])); })
    .append(&quot;svg:text&quot;)
      .attr({
        &quot;text-anchor&quot;: &quot;middle&quot;,
        &quot;y&quot;: 0,
        &quot;transform&quot;: &quot;translate(0,-12)&quot;,
        &quot;x&quot;: 0,
        &quot;class&quot;: &quot;label&quot;
      })
      .text(String);

  g_data.exit().remove();

  g = pc.svg.selectAll(&quot;.dimension&quot;);

  g.transition().duration(1100)
    .attr(&quot;transform&quot;, function(p) { return &quot;translate(&quot; + position(p) + &quot;)&quot;; })
    .style(&quot;opacity&quot;, 1)
  if (flags.shadows) paths(__.data, ctx.shadows);
  return this;
};

pc.brushable = function() {
  if (!g) pc.createAxes();

  // Add and store a brush for each axis.
  g.append(&quot;svg:g&quot;)
      .attr(&quot;class&quot;, &quot;brush&quot;)
      .each(function(d) {
        d3.select(this).call(
          yscale[d].brush = d3.svg.brush()
            .y(yscale[d])
            .on(&quot;brush&quot;, pc.brush)
        );
      })
    .selectAll(&quot;rect&quot;)
      .style(&quot;visibility&quot;, null)
      .attr(&quot;x&quot;, -15)
      .attr(&quot;width&quot;, 30)
  flags.brushable = true;
  return this;
};

// Jason Davies, http://bl.ocks.org/1341281
pc.reorderable = function() {
  if (!g) pc.createAxes();

  g.style(&quot;cursor&quot;, &quot;move&quot;)
    .call(d3.behavior.drag()
      .on(&quot;dragstart&quot;, function(d) {
        dragging[d] = this.__origin__ = xscale(d);
      })
      .on(&quot;drag&quot;, function(d) {
        dragging[d] = Math.min(w(), Math.max(0, this.__origin__ += d3.event.dx));
        __.dimensions.sort(function(a, b) { return position(a) - position(b); });
        xscale.domain(__.dimensions);
        pc.render();
        g.attr(&quot;transform&quot;, function(d) { return &quot;translate(&quot; + position(d) + &quot;)&quot;; })
      })
      .on(&quot;dragend&quot;, function(d) {
        delete this.__origin__;
        delete dragging[d];
        d3.select(this).transition().attr(&quot;transform&quot;, &quot;translate(&quot; + xscale(d) + &quot;)&quot;);
        pc.render();
      }));
  flags.reorderable = true;
  return this;
};

// pairs of adjacent dimensions
pc.adjacent_pairs = function(arr) {
  var ret = [];
  for (var i = 0; i &lt; arr.length-1; i++) {
    ret.push([arr[i],arr[i+1]]);
  };
  return ret;
};
pc.interactive = function() {
  flags.interactive = true;
  return this;
};

// Get data within brushes
pc.brush = function() {
  __.brushed = selected();
  events.brush.call(pc,__.brushed);
  pc.render();
};

// expose a few objects
pc.xscale = xscale;
pc.yscale = yscale;
pc.ctx = ctx;
pc.canvas = canvas;
pc.g = function() { return g; };

// TODO
pc.brushReset = function(dimension) {
  yscale[dimension].brush.clear()(
    pc.g()
      .filter(function(p) {
        return dimension == p;
      })
  )
  return this;
};

// rescale for height, width and margins
// TODO currently assumes chart is brushable, and destroys old brushes
pc.resize = function() {
  // selection size
  pc.selection.select(&quot;svg&quot;)
    .attr(&quot;width&quot;, __.width)
    .attr(&quot;height&quot;, __.height)
  pc.svg.attr(&quot;transform&quot;, &quot;translate(&quot; + __.margin.left + &quot;,&quot; + __.margin.top + &quot;)&quot;);

  // scales
  pc.autoscale();

  // axes, destroys old brushes. the current brush state should pass through in the future
  if (g) pc.createAxes().brushable();

  events.resize.call(this, {width: __.width, height: __.height, margin: __.margin});
  return this;
};

// highlight an array of data
pc.highlight = function(data) {
  pc.clear(&quot;highlight&quot;);
  d3.select(canvas.foreground).classed(&quot;faded&quot;, true);
  data.forEach(path_highlight);
  events.highlight.call(this,data);
  return this;
};

// clear highlighting
pc.unhighlight = function(data) {
  pc.clear(&quot;highlight&quot;);
  d3.select(canvas.foreground).classed(&quot;faded&quot;, false);
  return this;
};

// calculate 2d intersection of line a-&gt;b with line c-&gt;d
// points are objects with x and y properties
pc.intersection =  function(a, b, c, d) {
  return {
    x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),
    y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))
  };
};

function is_brushed(p) {
  return !yscale[p].brush.empty();
};

// data within extents
function selected() {
  var actives = __.dimensions.filter(is_brushed),
      extents = actives.map(function(p) { return yscale[p].brush.extent(); });

  // test if within range
  var within = {
    &quot;number&quot;: function(d,p,dimension) {
      return extents[dimension][0] &lt;= d[p] &amp;&amp; d[p] &lt;= extents[dimension][1]
    },
    &quot;string&quot;: function(d,p,dimension) {
      return extents[dimension][0] &lt;= yscale[p](d[p]) &amp;&amp; yscale[p](d[p]) &lt;= extents[dimension][1]
    }
  };

  return __.data
    .filter(function(d) {
      return actives.every(function(p, dimension) {
        return within[__.types[p]](d,p,dimension);
      });
    });
};

function position(d) {
  var v = dragging[d];
  return v == null ? xscale(d) : v;
}
  pc.toString = function() { return &quot;Parallel Coordinates: &quot; + __.dimensions.length + &quot; dimensions (&quot; + d3.keys(__.data[0]).length + &quot; total) , &quot; + __.data.length + &quot; rows&quot;; };
  
  pc.version = &quot;0.1.7&quot;;

  return pc;
};

d3.renderQueue = (function(func) {
  var _queue = [],                  // data to be rendered
      _rate = 10,                   // number of calls per frame
      _clear = function() {},       // clearing function
      _i = 0;                       // current iteration

  var rq = function(data) {
    if (data) rq.data(data);
    rq.invalidate();
    _clear();
    rq.render();
  };

  rq.render = function() {
    _i = 0;
    var valid = true;
    rq.invalidate = function() { valid = false; };

    function doFrame() {
      if (!valid) return false;
      if (_i &gt; _queue.length) return false;
      var chunk = _queue.slice(_i,_i+_rate);
      _i += _rate;
      chunk.map(func);
      d3.timer(doFrame);
    }

    doFrame();
  };

  rq.data = function(data) {
    rq.invalidate();
    _queue = data.slice(0);
    return rq;
  };

  rq.rate = function(value) {
    if (!arguments.length) return _rate;
    _rate = value;
    return rq;
  };

  rq.remaining = function() {
    return _queue.length - _i;
  };

  // clear the canvas
  rq.clear = function(func) {
    if (!arguments.length) {
      _clear();
      return rq;
    }
    _clear = func;
    return rq;
  };

  rq.invalidate = function() {};

  return rq;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
