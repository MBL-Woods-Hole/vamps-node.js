<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - routes/visuals/routes_counts_matrix.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>routes/visuals/routes_counts_matrix.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">494</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">57.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.03</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// counts_matrix.js
var path = require(&#039;path&#039;);
var fs = require(&#039;fs&#039;);
//var hdf5 = require(&#039;hdf5&#039;);
var COMMON  = require(&#039;./routes_common&#039;);
var C = require(&#039;../../public/constants&#039;);
var extend = require(&#039;util&#039;)._extend;
// biom format:dense: http://biom-format.org/documentation/format_versions/biom-1.0.html#example-biom-files
// {
//     &quot;id&quot;:null,
//     &quot;format&quot;: &quot;Biological Observation Matrix 0.9.1-dev&quot;,
//     &quot;format_url&quot;: &quot;http://biom-format.org/documentation/format_versions/biom-1.0.html&quot;,
//     &quot;type&quot;: &quot;OTU table&quot;,
//     &quot;generated_by&quot;: &quot;QIIME revision 1.4.0-dev&quot;,
//     &quot;date&quot;: &quot;2011-12-19T19:00:00&quot;,
//     &quot;rows&quot;:[
//             {&quot;id&quot;:&quot;GG_OTU_1&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;GG_OTU_2&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;GG_OTU_3&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;GG_OTU_4&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;GG_OTU_5&quot;, &quot;metadata&quot;:null}
//         ],
//     &quot;columns&quot;: [
//             {&quot;id&quot;:&quot;Sample1&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;Sample2&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;Sample3&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;Sample4&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;Sample5&quot;, &quot;metadata&quot;:null},
//             {&quot;id&quot;:&quot;Sample6&quot;, &quot;metadata&quot;:null}
//         ],
//     &quot;matrix_type&quot;: &quot;dense&quot;,
//     &quot;matrix_element_type&quot;: &quot;int&quot;,
//     &quot;shape&quot;: [5, 6],
//     &quot;data&quot;:  [[0,0,1,0,0,0],
//               [5,1,0,2,3,1],
//               [0,0,1,4,2,0],
//               [2,1,1,0,0,1],
//               [0,1,1,0,0,0]]
// }


module.exports = {


		get_biom_matrix: function(chosen_id_name_hash, post_items) {
			var date = new Date();
			var did,rank,db_tax_id,node_id,cnt,matrix_file;
			biom_matrix = {
					id: post_items.ts,
					format: &quot;Biological Observation Matrix&quot;,
					units: post_items.unit_choice,
					generated_by:&quot;VAMPS-NodeJS Version 2.0&quot;,
					date: date.toISOString(),
					rows:[],												// taxonomy (or OTUs, MED nodes) names
					columns:[],											// ORDERED dataset names
					column_totals:[],								// ORDERED datasets count sums
					max_dataset_count:0,						// maximum dataset count
					matrix_type: &#039;dense&#039;,
	    			matrix_element_type: &#039;int&#039;,
	     			shape: [],									// [row_count, col_count]
	     			data:  []										// ORDERED list of lists of counts: [ [],[],[] ... ]
	     		};
			//GLOBAL.boim_matrix;
			var ukeys = [];
			var unit_name_lookup = {};
			var unit_name_lookup_per_dataset = {};
			var unit_name_counts = {};
		
			// TESTING
			// data from DB or JSON_file or HTF5
			//var read_choices = [&#039;DB&#039;,&#039;JSON&#039;,&#039;HTF5&#039;];
			//var read_from = read_choices[0];
		  //if(read_from === &#039;JSON&#039;) {
				
		  for (var n in chosen_id_name_hash.ids) { // has correct order
				
				  did = chosen_id_name_hash.ids[n];	


				  if(post_items.unit_choice === &#039;tax_silva108_simple&#039;) {
							rank = post_items.tax_depth;
							rank_no = parseInt(C.RANKS.indexOf(rank))	+ 1;						
							
							console.log(&#039;did &#039;+did+&#039; rank: &#039;+rank+&#039; srank_no: &#039;+rank_no);
							
							// q =  &quot;SELECT domain_id, phylum_id, klass_id, order_id, family_id, genus_id, species_id, strain_id, count from summed_counts&quot;
							// q += &quot; JOIN rank using(rank_id)&quot;
							// q += &quot; WHERE dataset_id=&#039;&quot;+did+&quot;&#039; and rank=&#039;&quot;+rank+&quot;&#039;&quot;
							// console.log(q)
							// connection.db.query(q, function (err, rows) {
							// 	if(err){ throw err; }
							// 	for(i in rows){
							// 		//console.log(rows[i]);
							// 		cnt = rows[i].count;
							// 		tax_long_name = &#039;&#039;;
							//
							// 		for(var n=0;n&lt;=rank_no;n++){
							// 			var this_rank = C.RANKS[n];
							// 			var db_id = rows[i][this_rank+&#039;_id&#039;];
							// 			console.log(db_id);
							// 			var db_id_n_rank = db_id+&#039;_&#039;+this_rank;
							// 			var tax_node = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[db_id_n_rank];
							// 			tax_long_name += tax_node.taxon+&#039;;&#039;
							// 		}
							// 		tax_long_name = tax_long_name.slice(0,-1); // remove trailing &#039;;&#039;
							// 		console.log(&#039;long tax_name &#039;+tax_long_name+&#039; - &#039;+cnt.toString());
							// 		unit_name_lookup[tax_long_name] = 1;
							// 		unit_name_lookup_per_dataset = fillin_name_lookup_per_ds(unit_name_lookup_per_dataset, did, tax_long_name, cnt);
							// 	}
							// 	unit_name_counts = create_unit_name_counts(unit_name_lookup, chosen_id_name_hash, unit_name_lookup_per_dataset);
							//
							//
							// 	ukeys = remove_empty_rows(unit_name_counts);
							// 	ukeys = ukeys.filter(onlyUnique);
							// 	ukeys.sort();
							// 	// Bacteria;Bacteroidetes;Bacteroidia;Bacteroidales;Bacteroidaceae;Bacteroides
							// 	//console.log(unit_name_counts);
							// 	console.log(&#039;POSTx&#039;);
							// 	console.log(post_items);
							// 	biom_matrix 	= create_biom_matrix( biom_matrix, unit_name_counts, ukeys, chosen_id_name_hash );
							// 	if(post_items.update_data == true){
							// 	  biom_matrix = this.get_custom_biom_matrix( post_items, biom_matrix );
							// 	}else{
							// 	// nothing here for the time being.....
							// 	}
							// 	matrix_file = &#039;../../tmp/&#039;+post_items.ts+&#039;_count_matrix.biom&#039;;
							//
							// 	//COMMON.write_file( matrix_file, JSON.stringify(biom_matrix) );
							// 	COMMON.write_file( matrix_file, JSON.stringify(biom_matrix,null,2) );
							//
							// 	return biom_matrix;
							//
							// })
							for(var x in TAXCOUNTS[did]){

								if((x.match(/_/g) || []).length == rank_no){

									var ids = x.split(&#039;_&#039;);   // x === _5_55184_61061_62018_62239_63445
									cnt = TAXCOUNTS[did][x];
									var tax_long_name = &#039;&#039;;
									for(var y=1;y&lt;ids.length;y++){  // must start at 1 because leading &#039;_&#039;:  _2_55184
										var db_id = ids[y];
										var this_rank = C.RANKS[y-1];
										var db_id_n_rank = db_id+&#039;_&#039;+this_rank;
										var tax_node = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[db_id_n_rank];
										tax_long_name += tax_node.taxon+&#039;;&#039;;

									}
									tax_long_name = tax_long_name.slice(0,-1); // remove trailing &#039;;&#039;
									//console.log(&#039;long tax_name &#039;+tax_long_name+&#039; - &#039;+cnt.toString());
									unit_name_lookup[tax_long_name] = 1;
									unit_name_lookup_per_dataset = fillin_name_lookup_per_ds(unit_name_lookup_per_dataset, did, tax_long_name, cnt);
								}

							}


					}else if(post_items.unit_choice === &#039;tax_silva108_custom&#039;){
							// for(var t in post_items.custom_taxa) {
							// 	console.log(post_items.custom_taxa[t])
							// 		var name_and_rank = post_items.custom_taxa[t];
							// 		var items = name_and_rank.split(&#039;_&#039;);
							// 		var tax_short_name = items[0];
							// 		rank = items[1];
							// 		db_tax_id = new_taxonomy.taxa_tree_dict_map_by_name_n_rank[name_and_rank].db_id;
							// 		node_id = new_taxonomy.taxa_tree_dict_map_by_name_n_rank[name_and_rank].node_id;
							// 		// TODO: &#039;tax_long_name&#039; is already defined.
							// 		var tax_long_name = create_concatenated_tax_name(node_id);
							// 		unit_name_lookup[tax_long_name] = 1;
							// 		cnt = find_count_per_ds_and_rank(did, rank, db_tax_id);
							// 		unit_name_lookup_per_dataset = fillin_name_lookup_per_ds(unit_name_lookup_per_dataset, did, tax_long_name, cnt);
							// } // END :: for(t in post_items.custom_taxa) {
					}

			}
			
			
			unit_name_counts = create_unit_name_counts(unit_name_lookup, chosen_id_name_hash, unit_name_lookup_per_dataset);


			ukeys = remove_empty_rows(unit_name_counts);
			ukeys = ukeys.filter(onlyUnique);
			ukeys.sort();

			// Bacteria;Bacteroidetes;Bacteroidia;Bacteroidales;Bacteroidaceae;Bacteroides
			//console.log(unit_name_counts);
			console.log(&#039;POSTx&#039;);
			console.log(post_items);

			biom_matrix 	= create_biom_matrix( biom_matrix, unit_name_counts, ukeys, chosen_id_name_hash );

			if(post_items.update_data === true){

				biom_matrix = this.get_custom_biom_matrix( post_items, biom_matrix );

			}else{
			// nothing here for the time being.....
			}

			matrix_file = &#039;../../tmp/&#039;+post_items.ts+&#039;_count_matrix.biom&#039;;


			//COMMON.write_file( matrix_file, JSON.stringify(biom_matrix) );
			COMMON.write_file( matrix_file, JSON.stringify(biom_matrix,null,2) );

			return biom_matrix;

			function onlyUnique(value, index, self) {
				return self.indexOf(value) === index;
			}

	},

		 //
  // GET CUSTOM BIOM MATRIX
  //
  get_custom_biom_matrix: function(visual_post_items, mtx) {
    var custom_count_matrix = extend({},mtx);  // this clones count_matrix which keeps original intact.

    var max_cnt = mtx.max_dataset_count,
        min     = visual_post_items.min_range,
        max     = visual_post_items.max_range,
        norm    = visual_post_items.normalization;

    //console.log(&#039;in custom biom &#039;+max_cnt.toString());

        // Adjust for percent limit change
        var new_counts = [];
        var new_units = [];
        for(var c in custom_count_matrix.data) {

          var got_one = false;
          for(var k in custom_count_matrix.data[c]) {
            var thispct = (custom_count_matrix.data[c][k]*100)/custom_count_matrix.column_totals[k];
            if(thispct &gt; min &amp;&amp; thispct &lt; max){
              got_one = true;
            }
          }

          if(got_one){
            new_counts.push(custom_count_matrix.data[c]);
            new_units.push(custom_count_matrix.rows[c]);
          }else{
            console.log(&#039;rejecting &#039;+custom_count_matrix.rows[c].name);
          }
        }
        custom_count_matrix.data = new_counts;
        custom_count_matrix.rows = new_units;


        // Adjust for normalization
        var tmp1 = [];
        if (norm === &#039;maximum&#039;|| norm === &#039;max&#039;) {
            for(var cc in custom_count_matrix.data) {
              new_counts = [];
              for (var kc in custom_count_matrix.data[cc]) {
                  new_counts.push(parseInt( ( custom_count_matrix.data[cc][kc] * max_cnt ) / custom_count_matrix.column_totals[kc], 10) );

              }
              tmp1.push(new_counts);
            }
            custom_count_matrix.data = tmp1;
        }else if(norm === &#039;frequency&#039; || norm === &#039;freq&#039;){
            for (var cc1 in custom_count_matrix.data) {
              new_counts = [];
              for (var kc1 in custom_count_matrix.data[cc1]) {
                  new_counts.push(parseFloat( (custom_count_matrix.data[cc1][kc1] / custom_count_matrix.column_totals[kc1]).toFixed(6) ) );
              }
              tmp1.push(new_counts);
            }
            custom_count_matrix.data = tmp1;
        }else{
          // nothing here
        }

        // re-calculate totals
        var tots = [];
        // TODO: &quot;&#039;tmp&#039; is already defined.&quot;
	        var tmp2 = {};
        for(var cc2 in custom_count_matrix.data) {
          for(var kc2 in custom_count_matrix.data[cc2]) {
            if(kc2 in tmp2){
              tmp2[kc2] += custom_count_matrix.data[cc2][kc2];
            }else{
              tmp2[kc2] = custom_count_matrix.data[cc2][kc2];
            }
          }
        }
        for (var kc3 in custom_count_matrix.columns){
          tots.push(tmp2[kc3]);
        }
        custom_count_matrix.column_totals = tots;
        custom_count_matrix.shape = [ custom_count_matrix.rows.length, custom_count_matrix.columns.length ];

    //console.log(&#039;returning custom_count_matrix&#039;);
    return custom_count_matrix;
  },


};


//
//  R E M O V E  E M P T Y  R O W S
//
function remove_empty_rows(taxa_counts) {
		// remove empty rows:					
		
		var tmparr = [];
		for(var taxname in taxa_counts) {
			var sum = 0;
			for(var c in taxa_counts[taxname]){
				sum += taxa_counts[taxname][c];
				//console.log(k);
			}
			if(sum &gt; 0){
				tmparr.push(taxname);
			}	  			
		}
		return tmparr;

}
//
//	C R E A T E  U N I T  N A M E  C O U N T S
//
function create_unit_name_counts(unit_name_lookup, chosen_id_name_hash, unit_name_lookup_per_dataset) {
		
		var taxa_counts={};
	
	  for(var tax_name in unit_name_lookup){
	  	taxa_counts[tax_name]=[];
	  }	
	
	
		for (var n in chosen_id_name_hash.ids) { // correct order
	  	did = chosen_id_name_hash.ids[n];				  	
	  	for (var tax_name1 in unit_name_lookup) {
	  		if(did in unit_name_lookup_per_dataset &amp;&amp; tax_name1 in unit_name_lookup_per_dataset[did]) {
	  			cnt = unit_name_lookup_per_dataset[did][tax_name1];
	  			taxa_counts[tax_name1].push(cnt);
	  		} else {
	  			taxa_counts[tax_name1].push(0);
	  		}
	  	}
	  }
	  return taxa_counts;
}
//
//	F I L L I N  N A M E  L O O K U P  P E R  D S
//
function fillin_name_lookup_per_ds(lookup, did, tax_name, cnt) {
	
		
										
		if(did in lookup) {
  		if(tax_name in lookup[did]) {
  			lookup[did][tax_name] += parseInt(cnt);
  		}else{
  			lookup[did][tax_name] = parseInt(cnt);
  		}

  	}else{
  		lookup[did] = {};
  		if(tax_name in lookup[did]) {
  			lookup[did][tax_name] += parseInt(cnt);

  		}else{
  			lookup[did][tax_name] = parseInt(cnt);
  		}
  	}
  	return lookup;
}
//
//  C R E A T E  C O N C A T E N A T E D  T A X  N A M E
//
function create_concatenated_tax_name(node_id) {		
		var tax_name = &#039;&#039;;					  	
  	while(node_id !== 0) {  		
  		tax_name = new_taxonomy.taxa_tree_dict_map_by_id[node_id].taxon + &#039;;&#039; + tax_name;
  		node_id = new_taxonomy.taxa_tree_dict_map_by_id[node_id].parent_id;  	
  	}
  	return tax_name.replace(/;+$/,&#039;&#039;);  // remove trailing &#039;;&#039;

}
//
//  F I N D  C O U N T  P E R  D S  A N D  R A N K
//
function find_count_per_ds_and_rank(did, rank, db_tax_id) {
		cnt = 0;
  	if(did in TaxaCounts) {
	  	if(rank in TaxaCounts[did]) {
		  	if(db_tax_id in TaxaCounts[did][rank]) {
		  		cnt = TaxaCounts[did][rank][db_tax_id];				  		
		  	}
	  	}
  	}
  	return cnt;
}
//
//  C R E A T E  C O N C A T E N A T E D  T A X  N A M E
//
// function create_tax_name_list(node_id) {		
// 		var tax_name = [];					  	
//   	while(node_id !== 0) {  				  		
//   		//tax_name.unshift( new_taxonomy.taxa_tree_dict_map_by_id[node_id].taxon );
//   		tax_name = new_taxonomy.taxa_tree_dict_map_by_id[node_id].taxon  +&#039;;&#039;+ tax_name;
//   		node_id = new_taxonomy.taxa_tree_dict_map_by_id[node_id].parent_id;
//   	}
//   	return tax_name.replace(/;+$/,&#039;&#039;); // remove trailing &#039;;&#039;
//   	//return tax_name; // remove trailing &#039;;&#039;
// }
//
//
//
// function clean_custom_names(name_array) {
// 		name_array = name_array.filter(onlyUnique);
// 		name_array.sort(function(a, b){
// 				return b.length - a.length; // ASC -&gt; a - b; DESC -&gt; b - a
// 		});
		
// 		var ukeys2 = [];
// 		//ukeys.sort();
// 		var rank_num = 10; // too long rank to start
// 		console.log(name_array)
// 		for(var i in name_array) {
// 			got_one = true;
// 			for(n in ukeys2 ){
// 				if(ukeys2[n].indexOf(name_array[i]) === 0){
// 						console.log(&#039;MATCH! -no add &#039;+ name_array[i]);
// 						got_one = false;
// 					}else{
// 						//console.log(&#039;add &#039;+ukeys[i]+&#039; test against &#039;+ukeys2[n])
// 						//ukeys2.push(ukeys[i]);
// 						//got_one = true;
// 					}
// 			}
// 			if(got_one == true){
// 				ukeys2.push(name_array[i]);
// 			}
// 		}
// 		console.log(&#039;ukeys2&#039;)
// 		console.log(ukeys2);

// 		return ukeys2;
// }
//
//
//
function onlyUnique(value, index, self) {
	return self.indexOf(value) === index;
}
//
//	C R E A T E  B I O M  M A T R I X
//
function create_biom_matrix(biom_matrix, unit_name_counts, ukeys, chosen_id_name_hash ) {
	
	//console.log(ukeys);  // uname:
	//console.log(chosen_id_name_hash);
	for (var n in chosen_id_name_hash.names) {   // correct order
	    //console.log(dataset_ids[did])
	    biom_matrix.columns.push({ name: chosen_id_name_hash.names[n], metadata: {} });
	}
	// ukeys is sorted by alpha
	for(var uk in ukeys) {
		
		biom_matrix.rows.push({ name: ukeys[uk], metadata: {} });
		
		biom_matrix.data.push(unit_name_counts[ukeys[uk]]);
	}

	biom_matrix.shape = [biom_matrix.rows.length, biom_matrix.columns.length];
	
	var max_count = {};
	var max;
	if(ukeys === undefined) {
		max = 0;
	}else{
		for (var n1 in biom_matrix.columns) {
		  	max_count[biom_matrix.columns[n1].name] = 0;
		  	for(var d in biom_matrix.data) {
		  		max_count[biom_matrix.columns[n1].name] += biom_matrix.data[d][n1];
		  	}
		}
		max = 0;
		for (var n2 in chosen_id_name_hash.names) { 		// correct order
		  	biom_matrix.column_totals.push(max_count[chosen_id_name_hash.names[n2]]);
		  	if(max_count[chosen_id_name_hash.names[n2]] &gt; max){
		  		max = max_count[chosen_id_name_hash.names[n2]];
		  	}
		}
	}
	biom_matrix.max_dataset_count = max;
	//console.log(max_count);
	return(biom_matrix);
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
