<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - routes/visuals/routes_visualization.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>routes/visuals/routes_visualization.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2942</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">142.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">42.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var express = require(&#039;express&#039;);
var router = express.Router();

var util = require(&#039;util&#039;);
var url  = require(&#039;url&#039;);
var http = require(&#039;http&#039;);
var path = require(&#039;path&#039;);
var fs   = require(&#039;fs-extra&#039;);
var open = require(&#039;open&#039;);
var async = require(&#039;async&#039;);
var nodemailer = require(&#039;nodemailer&#039;);
var transporter = nodemailer.createTransport();
var zlib = require(&#039;zlib&#039;);
var Readable = require(&#039;readable-stream&#039;).Readable;

var helpers = require(&#039;../helpers/helpers&#039;);
var QUERY = require(&#039;../queries&#039;);

var COMMON  = require(&#039;./routes_common&#039;);
var META    = require(&#039;./routes_visuals_metadata&#039;);
//var PCOA    = require(&#039;./routes_pcoa&#039;);
var MTX     = require(&#039;./routes_counts_matrix&#039;);
//var HMAP    = require(&#039;./routes_distance_heatmap&#039;);
//var DEND    = require(&#039;./routes_dendrogram&#039;);
//var BCHARTS = require(&#039;./routes_bar_charts&#039;);
//var PCHARTS = require(&#039;./routes_pie_charts&#039;);
//var CTABLE  = require(&#039;./routes_counts_table&#039;);
//var PythonShell = require(&#039;python-shell&#039;);
var spawn = require(&#039;child_process&#039;).spawn;
var app = express();
// GLOBALS
PROJECT_TREE_PIDS = []
PROJECT_TREE_OBJ = []
DATA_TO_OPEN = {};
TAXCOUNTS = {};
METADATA  = {}; 
BIOM_MATRIX = {};
//var xmldom = require(&#039;xmldom&#039;);

// // init_node var node_class =
// var CustomTaxa  = require(&#039;./custom_taxa_class&#039;);

/*
 * GET visualization page.
 */
router.get(&#039;/view_selection/:filename&#039;, helpers.isLoggedIn, function(req, res) {
    console.log(&#039;req.body: view_selection::prefix--&gt;&gt;&#039;);
    console.log(req.body);
    console.log(&#039;req.body: view_selection&gt;&gt;prefix&#039;);
    var file_to_open = req.params.filename;
    var file_path_to_open = path.join(req.CONFIG.USER_FILES_BASE, req.user.username, file_to_open);
    var file_data_to_open = JSON.parse(fs.readFileSync(file_path_to_open, &#039;utf8&#039;))
    console.log(file_data_to_open)
    chosen_id_name_hash = file_data_to_open.id_name_hash
    visual_post_items = file_data_to_open.post_items
    dataset_ids = chosen_id_name_hash.ids;
    
    for(var i in dataset_ids){
      var did = dataset_ids[i]
      try{
          if(HDF5_TAXDATA == &#039;&#039;){
            if(visual_post_items.unit_choice == &#039;tax_rdp_simple&#039;){
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_rdp&quot;);
            }else{
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_silva119&quot;);
            }
            var path_to_file = path.join(files_prefix, did +&#039;.json&#039;);
            var jsonfile = require(path_to_file);
            TAXCOUNTS[did] = jsonfile[&#039;taxcounts&#039;];
            METADATA[did]  = jsonfile[&#039;metadata&#039;];
            
          }else{
            TAXCOUNTS[did] = helpers.get_attributes_from_hdf5_group(did, &#039;taxcounts&#039;)
            METADATA[did] = helpers.get_attributes_from_hdf5_group(did, &#039;metadata&#039;)
          }
      }
      catch(err){
        console.log(&#039;1- no file &#039;+err.toString()+&#039; Exiting&#039;);
        req.flash(&#039;Message&#039;, &quot;ERROR \
          Dataset file not found &#039;&quot;+dataset_ids[i] +&quot;.json&#039; (configuration file may be out of date)&quot;);
          //res.redirect(&#039;visuals_index&#039;);
          //return;
      }
      
    }
    BIOM_MATRIX = MTX.get_biom_matrix(chosen_id_name_hash, visual_post_items);
    var metadata = META.write_mapping_file(chosen_id_name_hash, visual_post_items);
    
    res.render(&#039;visuals/view_selection&#039;, {
                                title     :           &#039;VAMPS: Visuals Select&#039;,
                                referer   :           &#039;unit_selection&#039;,
                                chosen_id_name_hash : JSON.stringify(chosen_id_name_hash),
                                matrix    :           JSON.stringify(BIOM_MATRIX),
                                metadata  :           JSON.stringify(metadata),
                                constants :           JSON.stringify(req.CONSTS),
                                post_items:           JSON.stringify(visual_post_items),
                                user      :           req.user,
                                hostname  :           req.CONFIG.hostname,
                                gekey     : req.CONFIG.GOOGLE_EARTH_KEY,
	                          //locals: {flash: req.flash(&#039;infomessage&#039;)},
                                message   :           req.flash(&#039;Message&#039;)
    });
    
});
//
//  V I E W  S E L E C T I O N
//
router.post(&#039;/view_selection&#039;, helpers.isLoggedIn, function(req, res) {

  // This page (view_selection) comes after the datasets and units have been selected
  //    in the previous two pages.
  // It should be protected with isLoggedIn like /unit_selection below.
  // The function call will look like this when isLoggedIn is in place:
  //            router.post(&#039;/view_selection&#039;, isLoggedIn, function(req, res) {
  // This page is where the user will choose to view his/her selected visuals.
  // The left side will show a synopsis of what choices the user has made:
  //    datasets, normalization, units and any specifics such as tax rank, domain, NAs ....
  // The middle section will have a list of buttons allowing download of files
  // And the right side will have links to the previously selected visuals.
  // Before this page is rendered the visuals should have been created using the functions called below.
  // The visual pages will be created in a public directory and each page will have a random number or timestamp
  //    attached so the page is private and can be deleted later.
  // TESTING:
  //    There should be one or more datasets shown in list
  //    There should be one or more visual choices shown.
  //
  //var body = JSON.parse(req.body);
  
  console.log(&#039;req.body: view_selection--&gt;&gt;&#039;);
  console.log(req.body);
  console.log(&#039;&lt;&lt;--req.body: view_selection&#039;);
  
  helpers.start = process.hrtime();
  
//   req.body: view_selection--&gt;&gt;
// { unit_choice: &#039;tax_silva108_simple&#039;,
//   domains: [ &#039;Archaea&#039;, &#039;Bacteria&#039;, &#039;Eukarya&#039;, &#039;Organelle&#039;, &#039;Unknown&#039; ],
//   tax_depth: &#039;phylum&#039;,
//   select_type: &#039;clade&#039;,
//   meta_ckbx_toggle: &#039;all&#039;,
//   selected_metadata: [ &#039;sample_source&#039;, &#039;patient&#039;, &#039;gene_target&#039; ] }
// req.body: view_selection

  if(req.body.resorted === &#039;1&#039;){
    req.flash(&#039;message&#039;,&#039;The dataset order has been updated.&#039;);
    dataset_ids = req.body.ds_order;
    chosen_id_name_hash  = COMMON.create_chosen_id_name_hash(dataset_ids);	
  }else if(req.body.from_configuration_file === &#039;1&#039;){
    req.flash(&#039;message&#039;, &#039;Using data from configuration file.&#039;);
    TAXCOUNTS = {};
    METADATA  = {}; 
    //
    var config_file_path = path.join(req.CONFIG.USER_FILES_BASE, req.user.username, req.body.filename);
    var config_file_data = JSON.parse(fs.readFileSync(config_file_path, &#039;utf8&#039;))
    //console.log(file_data)
    visual_post_items = config_file_data.post_items;
    chosen_id_name_hash = config_file_data.id_name_hash;
    dataset_ids = chosen_id_name_hash.ids;
    for(var i in dataset_ids){
      var did = dataset_ids[i]
     
      try{
       
        
        if(HDF5_TAXDATA == &#039;&#039;){
            if(visual_post_items.unit_choice == &#039;tax_rdp_simple&#039;){
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_rdp&quot;);
            }else{
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_silva119&quot;);
            }
            var path_to_file = path.join(files_prefix, dataset_ids[i] +&#039;.json&#039;);
            var jsonfile = require(path_to_file);
            TAXCOUNTS[did] = jsonfile[&#039;taxcounts&#039;];
            METADATA[did]  = jsonfile[&#039;metadata&#039;];
        }else{
            
            TAXCOUNTS[did] = helpers.get_attributes_from_hdf5_group(did, &#039;taxcounts&#039;)
            METADATA[did] = helpers.get_attributes_from_hdf5_group(did, &#039;metadata&#039;)
        }
        
      }
      catch(err){
        console.log(&#039;2-no file &#039;+err.toString()+&#039; Exiting&#039;);
        req.flash(&#039;Message&#039;, &quot;ERROR \
          Dataset file not found &#039;&quot;+dataset_ids[i] +&quot;.json&#039; (configuration file may be out of date)&quot;);
          //res.redirect(&#039;visuals_index&#039;);
          //return;
      }
      
    }
  }else{
    // GLOBAL Variable
    visual_post_items = COMMON.save_post_items(req);

    dataset_ids = chosen_id_name_hash.ids;

    for(var i in dataset_ids){
      var did = dataset_ids[i]
     
      try{
       
        
        if(HDF5_TAXDATA == &#039;&#039;){
            if(visual_post_items.unit_choice == &#039;tax_rdp_simple&#039;){
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_rdp&quot;);
            }else{
                var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_silva119&quot;);
            }
            var path_to_file = path.join(files_prefix, dataset_ids[i] +&#039;.json&#039;);
            var jsonfile = require(path_to_file);
            TAXCOUNTS[did] = jsonfile[&#039;taxcounts&#039;];
            METADATA[did]  = jsonfile[&#039;metadata&#039;];
        }else{
            
            TAXCOUNTS[did] = helpers.get_attributes_from_hdf5_group(did, &#039;taxcounts&#039;)
            METADATA[did] = helpers.get_attributes_from_hdf5_group(did, &#039;metadata&#039;)
        }
        
      }
      catch(err){
        console.log(&#039;2-no file &#039;+err.toString()+&#039; Exiting&#039;);
        req.flash(&#039;Message&#039;, &quot;ERROR \
          Dataset file not found &#039;&quot;+dataset_ids[i] +&quot;.json&#039; (configuration file may be out of date)&quot;);
          //res.redirect(&#039;visuals_index&#039;);
          //return;
      }
      
    }

  }
  
  
  //console.log(&#039;chosen_id_name_hash:&gt;&gt;&#039;);
  //console.log(chosen_id_name_hash);
  //console.log(&#039;&lt;&lt;chosen_id_name_hash&#039;);
    
  //console.log(&#039;TAXCOUNTS:&gt;&gt;&#039;);
  //console.log(TAXCOUNTS);
  //console.log(&#039;&lt;&lt;TAXCOUNTS&#039;);
  // GLOBAL
  var timestamp = +new Date();  // millisecs since the epoch!
  timestamp = req.user.username + &#039;_&#039; + timestamp;
  visual_post_items.ts = timestamp;
  distance_matrix = {};
  BIOM_MATRIX = MTX.get_biom_matrix(chosen_id_name_hash, visual_post_items);
  visual_post_items.max_ds_count = BIOM_MATRIX.max_dataset_count;
  

  console.log(&#039;VS--visual_post_items:&gt;&gt;&#039;);
  //console.log(visual_post_items);
  console.log(&#039;&lt;&lt;VS--visual_post_items:&#039;);
 

  // GLOBAL
  //console.log(&#039;metadata&gt;&gt;&#039;);
  //metadata = META.write_metadata_file(chosen_id_name_hash, visual_post_items);
  var metadata = META.write_mapping_file(chosen_id_name_hash, visual_post_items);
  //metadata = JSON.parse(metadata);
  //console.log(metadata);
  //console.log(&#039;&lt;&lt;metadata&#039;);
  //console.log(&#039;MAP:::&#039;);
  //console.log(new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank)
  //console.log(new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[&quot;724_class&quot;][&quot;taxon&quot;])

  //
  //uid_matrix = MTX.fill_in_counts_matrix( selection_obj, unit_field );  // just ids, but filled in zeros
  // {unit_id:[cnt1,cnt2...] // counts are in ds order
  
  //console.log(BIOM_MATRIX);


  res.render(&#039;visuals/view_selection&#039;, {
                                title     :           &#039;VAMPS: Visuals Select&#039;,
                                referer   :           &#039;unit_selection&#039;,
                                chosen_id_name_hash : JSON.stringify(chosen_id_name_hash),
                                matrix    :           JSON.stringify(BIOM_MATRIX),
                                metadata  :           JSON.stringify(metadata),
                                constants :           JSON.stringify(req.CONSTS),
                                post_items:           JSON.stringify(visual_post_items),
                                user      :           req.user,
                                hostname  :           req.CONFIG.hostname,
                                gekey     : req.CONFIG.GOOGLE_EARTH_KEY,
	                          //locals: {flash: req.flash(&#039;infomessage&#039;)},
                                message   :           req.flash(&#039;Message&#039;)
                 });

});


//
// U N I T  S E L E C T I O N
//
// use the isLoggedIn function to limit exposure of each page to
// logged in users only
router.post(&#039;/unit_selection&#039;, helpers.isLoggedIn, function(req, res) {
//router.post(&#039;/unit_selection&#039;,  function(req, res) {

  // TESTING:
  //    There should be one or more datasets shown in list
  //    The Submit button should return with an alert error if no display checkboxes are checked
  //    There should be a &#039;default&#039; Units Selection present (This point is debatable -- the other option
  //        would be leave blank and force the user to select). I chose Silva108--Simple Taxonomy as default.
  //    The &#039;Display Output&#039; section should list the items from public/constants.js
  //    The &#039;Normailzation&#039; section should list the items from public/constants.js with the NotNormalized option
  //        checked by default.
  
  console.log(&#039;req.body: unit_selection--&gt;&gt;&#039;);
  console.log(req.body);
  console.log(&#039;req.body: unit_selection&#039;);
  if(typeof  unit_choice === &#039;undefined&#039;){
    unit_choice = &#039;tax_silva119_simple&#039;;
  }
  console.log(unit_choice);
  var dataset_ids = [];
  if(req.body.resorted === &#039;1&#039;){
  	dataset_ids = req.body.ds_order;	
  }else{
    dataset_ids = JSON.parse(req.body.dataset_ids);
  }


  // else if(req.body.retain_data === &#039;1&#039;){
  //   dataset_ids = JSON.parse(req.body.dataset_ids);	
  // }else{
  //   dataset_ids = req.body.dataset_ids;
  // }

  console.log(&#039;dataset_ids &#039;+dataset_ids);
  if (dataset_ids === undefined || dataset_ids.length === 0){
      console.log(&#039;redirecting back -- no data selected&#039;);
   	 req.flash(&#039;nodataMessage&#039;, &#039;Select Some Datasets&#039;);
   	 //res.redirect(&#039;visuals_index&#039;);
     return;
  }else{
	  // Global TAXCOUNTS, METADATA
	  TAXCOUNTS = {};
    
	  METADATA  = {}; 
	  // Gather just the tax data of selected datasets
	  //

    
    for(var i in dataset_ids){
      //console.log(&#039;ds&#039;,dataset_ids[i])
      var did = dataset_ids[i]
      
        
        if(HDF5_TAXDATA == &#039;&#039;){
            // use default taxonomy here (may choose other on this page)
            var files_prefix = path.join(req.CONFIG.JSON_FILES_BASE, NODE_DATABASE+&quot;--datasets_silva119&quot;);
            var path_to_file = path.join(files_prefix, dataset_ids[i] +&#039;.json&#039;);
            var jsonfile = require(path_to_file);
            //TAXCOUNTS[dataset_ids[i]] = jsonfile[&#039;taxcounts&#039;];
            METADATA[dataset_ids[i]]  = jsonfile[&#039;metadata&#039;];
        }else{
            TAXCOUNTS[did] = helpers.get_attributes_from_hdf5_group(did, &#039;taxcounts&#039;)
            METADATA[did] = helpers.get_attributes_from_hdf5_group(did, &#039;metadata&#039;)
        }
        
        


     
		  
	  }
	  //console.log(JSON.stringify(METADATA))
	  //console.log(&#039;49x&#039;,JSON.stringify(TAXCOUNTS[&#039;49&#039;]))
    //console.log(JSON.stringify(TAXCOUNTS2[49]))
	  console.log(&#039;Pulling xTAXCOUNTS and METADATA -- ONLY for datasets selected (from files)&#039;);
	  //console.log(&#039;TAXCOUNTS= &#039;+JSON.stringify(TAXCOUNTS));
    //console.log(&#039;METADATA= &#039;+JSON.stringify(METADATA));
	  var available_units = req.CONSTS.AVAILABLE_UNITS; // [&#039;med_node_id&#039;,&#039;otu_id&#039;,&#039;taxonomy_gg_id&#039;]

	  // GLOBAL Variable
	  chosen_id_name_hash           = COMMON.create_chosen_id_name_hash(dataset_ids);

	  var custom_metadata_headers   = COMMON.get_metadata_selection(chosen_id_name_hash.ids,METADATA,&#039;custom&#039;);
	  var required_metadata_headers = COMMON.get_metadata_selection(chosen_id_name_hash.ids,METADATA,&#039;required&#039;);
	  console.log(required_metadata_headers)
	  //console.log(chosen_id_name_hash)
	  // // benchmarking
	  // var start = process.hrtime();
	  //
	  // // benchmarking
	  // var elapsed_time = function(note){
	  //     var precision = 3; // 3 decimal places
	  //     var elapsed = process.hrtime(start)[1] / 1000000; // divide by a million to get nano to milli
	  //     console.log(process.hrtime(start)[0] + &quot; s, &quot; + elapsed.toFixed(precision) + &quot; ms - &quot; + note); // print message + time
	  //     //start = process.hrtime(); // reset the timer
	  // };
    //console.log(custom_metadata_headers)
	  // benchmarking
	  helpers.start = process.hrtime();
	  helpers.elapsed_time(&quot;START: select from sequence_pdr_info and sequence_uniq_info--&gt;&gt;&gt;&gt;&gt;&gt;&quot;);


	  console.log(&#039;chosen_id_name_hash--&gt;&#039;);
	  console.log(chosen_id_name_hash);
	  console.log(chosen_id_name_hash.ids.length);
	  console.log(&#039;&lt;--chosen_id_name_hash&#039;);
    console.log(&#039;units: &#039;,unit_choice)

	  res.render(&#039;visuals/unit_selection&#039;, {
	                    title: &#039;VAMPS: Units Selection&#039;,
                      referer: &#039;visuals_index&#039;,
	                    chosen_id_name_hash: JSON.stringify(chosen_id_name_hash),
	                    constants    : JSON.stringify(req.CONSTS),
	                    md_cust      : JSON.stringify(custom_metadata_headers),  // should contain all the cust headers that selected datasets have
		  				        md_req       : JSON.stringify(required_metadata_headers),
                      unit_choice : unit_choice,
		  				        message      : req.flash(&#039;Message&#039;),
	                    user         : req.user,hostname: req.CONFIG.hostname,
	  });  // end render
  }
    // benchmarking
  helpers.elapsed_time(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4 After Page Render &lt;&lt;&lt;&lt;&lt;&lt;&quot;);


}); // end fxn

/*
 * GET visualization page.
 */
router.get(&#039;/visuals_index&#039;, helpers.isLoggedIn, function(req, res) {
   // This page is arrived at using GET from the Main Menu
    // It will be protected usind the helpers.isLoggedIn function
    // TESTING:
    //      Should show the closed project list on initialize
    //      The javascript functions (load_project_select, set_check_project, open_datasets, toggle_selected_datasets)
    //        should work to open the project (show and check the datasets) when either the plus image is clicked or the
    //        checkbox is selected. Clicking the minus image should deselect the datasets and close the dataset list.
    //        While the project is open clicking on the project checkbox should toggle all the datasets under it.
    //      Clicking the submit button when no datasets have been selected should result in an alert box and a
    //      return to the page.
    //console.log(PROJECT_INFORMATION_BY_PID);
    console.log(&#039;req.body index&#039;)
    //console.log(req.body)

    //console.log(ALL_DATASETS);
    // GLOBAL
    SHOW_DATA = ALL_DATASETS;
    TAXCOUNTS = {}; // empty out this global variable: fill it in unit_selection
    METADATA  = {};
    unit_choice = &#039;tax_silva119_simple&#039;;
    // GLOBAL
    DATA_TO_OPEN = {};
    if(req.body.data_to_open){
      // open many projects
      obj = JSON.parse(req.body.data_to_open)
      for(pj in obj){
        pid = PROJECT_INFORMATION_BY_PNAME[pj].pid
        DATA_TO_OPEN[pid] = obj[pj]
      }
      //console.log(&#039;got data to open &#039;+data_to_open)
    }else if(req.body.project){
      // open whole project
      DATA_TO_OPEN[req.body.project_id] = DATASET_IDS_BY_PID[req.body.project_id];
    }
    console.log(&#039;DATA_TO_OPEN&#039;);
    console.log(DATA_TO_OPEN);


    res.render(&#039;visuals/visuals_index&#039;, {
                                  title       : &#039;VAMPS: Select Datasets&#039;,
                                  subtitle    : &#039;Dataset Selection Page&#039;,
                                  proj_info   : JSON.stringify(PROJECT_INFORMATION_BY_PID),
                                  constants   : JSON.stringify(req.CONSTS),
                                  md_names    : AllMetadataNames,
                                  filtering   : 0,
                                  portal_to_show : &#039;&#039;,
                                  data_to_open: JSON.stringify(DATA_TO_OPEN),	  							              
                                  user        : req.user,
                                  hostname    : req.CONFIG.hostname,
                                  message     : req.flash(&#039;nodataMessage&#039;),
                              });
  });

router.post(&#039;/visuals_index&#039;, helpers.isLoggedIn, function(req, res) {
  // This page is arrived at using GET from the Main Menu
  // It will be protected usind the helpers.isLoggedIn function
  // TESTING:
  //      Should show the closed project list on initialize
  //      The javascript functions (load_project_select, set_check_project, open_datasets, toggle_selected_datasets)
  //        should work to open the project (show and check the datasets) when either the plus image is clicked or the
  //        checkbox is selected. Clicking the minus image should deselect the datasets and close the dataset list.
  //        While the project is open clicking on the project checkbox should toggle all the datasets under it.
  //      Clicking the submit button when no datasets have been selected should result in an alert box and a
  //      return to the page.
  //console.log(PROJECT_INFORMATION_BY_PID);
  console.log(&#039;req.body index&#039;)
  //console.log(req.body)

  //console.log(ALL_DATASETS);
  // GLOBAL
  SHOW_DATA = ALL_DATASETS;
  TAXCOUNTS = {}; // empty out this global variable: fill it in unit_selection
  METADATA  = {};
  unit_choice = &#039;tax_silva119_simple&#039;;
  // GLOBAL
  DATA_TO_OPEN = {};
  if(req.body.data_to_open){
    // open many projects
    obj = JSON.parse(req.body.data_to_open)
    for(pj in obj){
      pid = PROJECT_INFORMATION_BY_PNAME[pj].pid
      DATA_TO_OPEN[pid] = obj[pj]
    }
    //console.log(&#039;got data to open &#039;+data_to_open)
  }else if(req.body.project){
    // open whole project
    DATA_TO_OPEN[req.body.project_id] = DATASET_IDS_BY_PID[req.body.project_id];
  }
  console.log(&#039;DATA_TO_OPEN&#039;);
  console.log(DATA_TO_OPEN);
  
  
  res.render(&#039;visuals/visuals_index&#039;, {
                                title       : &#039;VAMPS: Select Datasets&#039;,
                                subtitle    : &#039;Dataset Selection Page&#039;,
                                proj_info   : JSON.stringify(PROJECT_INFORMATION_BY_PID),
                                constants   : JSON.stringify(req.CONSTS),
                                md_names    : AllMetadataNames,
                                filtering   : 0,
                                portal_to_show : &#039;&#039;,
                                data_to_open: JSON.stringify(DATA_TO_OPEN),	  							              
                                user        : req.user,
                                hostname    : req.CONFIG.hostname,
                                message     : req.flash(&#039;nodataMessage&#039;),
                            });
});

//
//
//
router.post(&#039;/reorder_datasets&#039;, helpers.isLoggedIn, function(req, res) {
    
    var ts = visual_post_items.ts || null;
    res.render(&#039;visuals/reorder_datasets&#039;, {
                                title   : &#039;VAMPS: Reorder Datasets&#039;,
                                chosen_id_name_hash: JSON.stringify(chosen_id_name_hash),
                                constants    : JSON.stringify(req.CONSTS),
								                referer: req.body.referer,
                                ts : ts,
                                user: req.user, hostname: req.CONFIG.hostname,
                            });
  //console.log(chosen_id_name_hash)
});
//
//
//
router.post(&#039;/view_saved_datasets&#039;, helpers.isLoggedIn, function(req, res) {
  // this fxn is required for viewing list of saved datasets
  // when &#039;toggle open button is activated&#039;
  fxn = req.body.fxn;
  //console.log(&#039;XX&#039;+JSON.stringify(req.body));
  var file_path = path.join(req.CONFIG.USER_FILES_BASE, req.body.user, req.body.filename);
  console.log(file_path);
  var dataset_ids = [];
  fs.readFile(file_path, &#039;utf8&#039;,function(err,data) {
    if (err) {
      msg = &#039;ERROR Message &#039;+err;
        helpers.render_error_page(req,res,msg);
    }else{    
      console.log(data)
      res.send(data);
    }
  });
});
router.post(&#039;/get_saved_datasets&#039;, helpers.isLoggedIn, function(req, res) {
  // this fxn is required for viewing list of saved datasets
  // when &#039;toggle open button is activated&#039;
  console.log(req.body.filename)
  //console.log(&#039;XX&#039;+JSON.stringify(req.body));
  var file_path = path.join(req.CONFIG.USER_FILES_BASE, req.body.user, req.body.filename);
  console.log(file_path);
  var dataset_ids = [];
  fs.readFile(file_path, &#039;utf8&#039;,function(err,data) {
    if (err) {
      msg = &#039;ERROR Message &#039;+err;
        helpers.render_error_page(req,res,msg);
    }else{    
      res.redirect(&#039;unit_selection&#039;);
    }
  });
});
//
//
//
router.post(&#039;/heatmap&#039;, helpers.isLoggedIn, function(req, res) {
    //console.log(&#039;found routes_test_heatmap&#039;)
    //console.log(&#039;req.body hm&#039;);
    //console.log(req.body);
    //console.log(&#039;req.body hm&#039;);
    
    var ts = req.body.ts;
    var metric = req.body.metric;
    var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    var biom_file = path.join(pwd,&#039;tmp&#039;, biom_file_name);
    //console.log(&#039;mtx1&#039;)
   
    var html = &#039;&#039;;
    var title = &#039;VAMPS&#039;;

    var distmtx_file_name = ts+&#039;_distance.csv&#039;;
    var distmtx_file = path.join(pwd,&#039;tmp&#039;,distmtx_file_name);
    
    var options = {
     scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
       args :       [ &#039;-in&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;dheatmap&#039;, &#039;--outdir&#039;, path.join(pwd,&#039;tmp&#039;), &#039;--prefix&#039;, ts],
     };
        
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    
    console.log(options.scriptPath+&#039;/distance.py &#039;+options.args.join(&#039; &#039;));
    var heatmap_process = spawn( options.scriptPath+&#039;/distance.py&#039;, options.args, {
            env:{&#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH},
            detached: true, 
            //stdio: [ &#039;ignore&#039;, null, log ] // stdin, stdout, stderr
            stdio: &#039;pipe&#039; // stdin, stdout, stderr
        });  
    
    
    var stdout = &#039;&#039;;
    heatmap_process.stdout.on(&#039;data&#039;, function (data) {
        //console.log(&#039;stdout: &#039; + data);
        //data = data.toString().replace(/^\s+|\s+$/g, &#039;&#039;);
        data = data.toString();
        stdout += data;
    });
    var stderr = &#039;&#039;;
    heatmap_process.stderr.on(&#039;data&#039;, function (data) {
        console.log(&#039;stderr: &#039; + data);
        //data = data.toString().replace(/^\s+|\s+$/g, &#039;&#039;);
        data = data.toString();
        stderr += data;
    });
         
    heatmap_process.on(&#039;close&#039;, function (code) {
        console.log(&#039;heatmap_process process exited with code &#039; + code);
               
        //var last_line = ary[ary.length - 1];
        if(code === 0){   // SUCCESS     
          try{
            console.log(stdout)
            distance_matrix = JSON.parse(stdout);
          }
          catch(err){
            distance_matrix = {&#039;ERROR&#039;:err};
          }  
            res.render(&#039;visuals/partials/create_distance_heatmap&#039;,{
                  dm        : distance_matrix,
                  hash      : JSON.stringify(chosen_id_name_hash),                      
                  constants : JSON.stringify(req.CONSTS),
                  ts        : ts
              }); 

        }else{
          console.log(&#039;output: &#039;+stderr);
          res.send(stderr);
        }      
    });   

});


//
//   F R E Q U E N C Y  H E A T M A P
//
router.post(&#039;/frequency_heatmap&#039;, helpers.isLoggedIn, function(req, res) {

  console.log(&#039;in Freq HM&#039;);
  var ts = req.body.ts;
  var metric = req.body.metric;
  var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
  var biom_file = path.join(process.env.PWD, &#039;tmp&#039;,biom_file_name);
  var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
  var html = &#039;&#039;;
  var title = &#039;VAMPS&#039;;

  var distmtx_file_name = ts+&#039;_distance.csv&#039;;
  var distmtx_file = path.join(pwd,&#039;tmp&#039;,distmtx_file_name);
  var metric = visual_post_items.selected_distance
  var tmp_path = path.join(process.env.PWD,&#039;tmp&#039;); 
  var tax_depth = visual_post_items.tax_depth

  var options = {
        scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
        args :       [ tmp_path, ts, metric, tax_depth],
      };

  var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
  
  
  console.log(options.scriptPath+&#039;/fheatmap.R &#039;+options.args.join(&#039; &#039;));
  var fheatmap_process = spawn( options.scriptPath+&#039;/fheatmap.R&#039;, options.args, {
          env:{&#039;PATH&#039;:req.CONFIG.PATH},
          detached: true, 
          //stdio: [ &#039;ignore&#039;, null, log ]
          stdio: &#039;pipe&#039;  // stdin, stdout, stderr
      }); 
  stdout = &#039;&#039;;
  fheatmap_process.stdout.on(&#039;data&#039;, function (data) {
      
      stdout += data;    
   
  });
  stderr = &#039;&#039;;
  fheatmap_process.stderr.on(&#039;data&#039;, function (data) {
      
      stderr += data;    
   
  }); 
  
  fheatmap_process.on(&#039;close&#039;, function (code) {
        console.log(&#039;fheatmap_process process exited with code &#039; + code);
        //distance_matrix = JSON.parse(output);
        //var last_line = ary[ary.length - 1];
        if(code === 0){   // SUCCESS       
              //image_file = ts+&#039;_heatmap.pdf&#039;;
              //image_file = path.join(process.env.PWD,&#039;tmp&#039;, ts+&#039;_heatmap.pdf&#039;);
              //res.send(&quot;&lt;img src=&#039;/&quot;+image_file+&quot;&#039;&gt;&quot;);
              
              //var viz_width = 1200;
              //var viz_height = (visual_post_items.no_of_datasets*12)+100;
              var image = &#039;/&#039;+ts+&#039;_fheatmap.pdf&#039;;
              //console.log(image)
              html = &quot;&lt;div id=&#039;pdf&#039;&gt;&quot;;
              html += &quot;&lt;object data=&#039;&quot;+image+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039; width=&#039;100%&#039; height=&#039;700&#039; /&gt;&quot;;
              html += &quot; &lt;p&gt;ERROR in loading pdf file&lt;/p&gt;&quot;;
              html += &quot;&lt;/object&gt;&lt;/div&gt;&quot;;
              res.send(html);

              return;
              // fs.readFile(image_file, &#039;utf8&#039;, function (err,data) {
              //   if (err) {
              //      console.log(err);
              //      res.send(&#039;FreqHeatmap File Error&#039;);
              //    }
              //    console.log(&#039;Reading: &#039;+image)
              //    //data_items = data.split(&#039;\n&#039;)
                 
              //    //X=data_items.slice(1,data_items.length)
              //    //d = X.join(&#039;\n&#039;)
              //    //console.log(d)
              //    res.send(data);
              // });
                                        
        }else{
          console.log(&#039;ERROR&#039;);
          res.send(&#039;Frequency Heatmap R Script Error:&#039;+stderr);
        }      
  });   
  

});


//
//
//
router.post(&#039;/dendrogram&#039;, helpers.isLoggedIn, function(req, res) {
    console.log(&#039;found routes_dendrogram-x&#039;);
    ///// this vesion of dendrogram is or running d3 on CLIENT: Currently:WORKING
    ///// It passes the newick string back to view_selection.js
    ///// and tries to construct the svg there before showing it.
    console.log(&#039;req.body dnd&#039;);
    console.log(req.body);
    console.log(&#039;req.body dnd&#039;);
    var ts = req.body.ts;
    var metric = req.body.metric;
    var script = req.body.script; // python, phylogram or phylonator
    var image_type = req.body.image_type;  // png(python script) or svg
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    //console.log(&#039;image_type &#039;+image_type);
    // see:  http://bl.ocks.org/timelyportfolio/59acc3853b02e47e0dfc
  
    var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
    var biom_file = path.join(pwd,&#039;tmp&#039;,biom_file_name);

    var html = &#039;&#039;;
    var title = &#039;VAMPS&#039;;

    var distmtx_file_name = ts+&#039;_distance.csv&#039;;
    var distmtx_file = path.join(pwd,&#039;tmp&#039;,distmtx_file_name);
    

    var options = {
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ &#039;-in&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;dendrogram-&#039;+image_type, &#039;--outdir&#039;, path.join(pwd,&#039;tmp&#039;), &#039;--prefix&#039;, ts ],
    };
   
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    console.log(options.scriptPath+&#039;/distance.py &#039;+options.args.join(&#039; &#039;));
    var dendrogram_process = spawn( options.scriptPath+&#039;/distance.py&#039;, options.args, {
            env:{&#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH},
            detached: true, 
            //stdio: [ &#039;ignore&#039;, null, log ] // stdin, stdout, stderr
            stdio: &#039;pipe&#039;  // stdin, stdout, stderr
    });  
    
    var stdout = &#039;&#039;;
    dendrogram_process.stdout.on(&#039;data&#039;, function (data) {
        //
        //data = data.toString().replace(/^\s+|\s+$/g, &#039;&#039;);
        data = data.toString();
        stdout += data;

    });
    var stderr = &#039;&#039;;
    dendrogram_process.stderr.on(&#039;data&#039;, function (data) {
        console.log(&#039;stderr: &#039; + data);
        //data = data.toString().replace(/^\s+|\s+$/g, &#039;&#039;);
        data = data.toString();
        stderr += data;
    });
    
    dendrogram_process.on(&#039;close&#039;, function (code) {
        console.log(&#039;dendrogram_process process exited with code &#039; + code);
      
        //var last_line = ary[ary.length - 1];
        if(code === 0){   // SUCCESS       
          if(image_type == &#039;svg&#039;){
                    console.log(&#039;stdout: &#039; + stdout);
                    lines = stdout.split(&#039;\n&#039;)
                    for(n in lines){
                      if(lines[n].substring(0,6) == &#039;NEWICK&#039; ){
                        tmp = lines[n].split(&#039;=&#039;)
                        continue
                      }
                    }

                    
                    try{
                      newick = JSON.parse(tmp[1]);
                      console.log(newick)
                    }
                    catch(err){
                      newick = {&quot;ERROR&quot;:err};
                    }
                    res.send(newick);
                    return;

          }else{  // &#039;pdf&#039;
                    var viz_width = 1200;
                    var viz_height = (visual_post_items.no_of_datasets*12)+100;
                    var image = &#039;/&#039;+ts+&#039;_dendrogram.pdf&#039;;
                    //console.log(image)
                    html = &quot;&lt;div id=&#039;pdf&#039;&gt;&quot;;
                    html += &quot;&lt;object data=&#039;&quot;+image+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039; width=&#039;100%&#039; height=&#039;&quot;+viz_height+&quot;&#039; /&gt;&quot;;
                    html += &quot; &lt;p&gt;ERROR in loading pdf file&lt;/p&gt;&quot;;
                    html += &quot;&lt;/object&gt;&lt;/div&gt;&quot;;
                    res.send(html);
                    return;
          }                                     
        }else{
          console.log(&#039;stderr: &#039;+stderr);
          res.send(&#039;Script Error&#039;);
        }      
    });   
    
    
    
 
});

//
// P C O A
//
router.post(&#039;/pcoa&#039;, helpers.isLoggedIn, function(req, res) {
    console.log(&#039;in PCoA&#039;);
    //console.log(metadata);
    var ts = req.body.ts;
    var rando = Math.floor((Math.random() * 100000) + 1);  // required to prevent image caching
    var metric = req.body.metric;
    var image_type = req.body.image_type;
    //var image_file = ts+&#039;_&#039;+metric+&#039;_pcoaR&#039;+rando.toString()+&#039;.pdf&#039;;
    var image_file = ts+&#039;_pcoa.pdf&#039;;
    var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
    var biom_file = path.join(process.env.PWD,&#039;tmp&#039;, biom_file_name);
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    var tmp_path = path.join(process.env.PWD,&#039;tmp&#039;);
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    
    md1 = req.body.md1 || &quot;Project&quot;;
    md2 = req.body.md2 || &quot;Description&quot;;
        
      // var options = {
      //   scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      //   args :       [ &#039;-in&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;pcoa_2d&#039;, &#039;--site_base&#039;, process.env.PWD, &#039;--prefix&#039;, ts],
      // };
      var options2 = {
        scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
        args :       [ tmp_path, ts, metric, md1, md2, image_file],
      };
      console.log(options2.scriptPath+&#039;/pcoa2.R &#039;+options2.args.join(&#039; &#039;));
     
      var pcoa_process = spawn( options2.scriptPath+&#039;/pcoa2.R&#039;, options2.args, {
          env:{&#039;PATH&#039;:req.CONFIG.PATH},
          detached: true, 
          stdio: [ &#039;ignore&#039;, null, log ]
          //stdio: &#039;pipe&#039; // stdin, stdout, stderr
      });  
  
      
      pcoa_process.on(&#039;close&#039;, function (code) {
          //console.log(&#039;pcoa_process process exited with code &#039; + code+&#039; -- &#039;+output);
          //distance_matrix = JSON.parse(output);
          //var last_line = ary[ary.length - 1];
          if(code === 0){   // SUCCESS       
              
            //html = &quot;&lt;img src=&#039;/&quot;+image_file+&quot;&#039;&gt;&quot;;
            //var image = path.join(&#039;/tmp/&#039;,image_file);              
            var html = &quot;&lt;div id=&#039;pdf&#039;&gt;&quot;;
            html += &quot;&lt;object data=&#039;/&quot;+image_file+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039; width=&#039;1000&#039; height=&#039;600&#039; /&gt;&quot;;
            html += &quot; &lt;p&gt;ERROR in loading pdf file&lt;/p&gt;&quot;;
            html += &quot;&lt;/object&gt;&lt;/div&gt;&quot;;
            //console.log(html);                 
                                                      
          }else{
              console.log(&#039;ERROR&#039;);
              html=&#039;PCoA Script Failure -- Try a deeper rank, or more metadata or datasets&#039;;
          } 

          res.send(html);

      });   
      
        
    
    
});
//
//  EMPEROR....
// POST is for PC file link
router.post(&#039;/pcoa3d&#039;, helpers.isLoggedIn, function(req, res) {
        
        var ts = visual_post_items.ts; 
        var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
        var pc_file_name = ts+&#039;.pc&#039;;
        //var pc_file = path.join(pwd,&#039;tmp&#039;, pc_file_name);
        ///////////////////////////////////////////////////
  console.log(&#039;in 3D&#039;);
  console.log(visual_post_items);
  var ts = visual_post_items.ts;    
  var metric = visual_post_items.selected_distance;
  
  var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
  var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
  var biom_file = path.join(pwd,&#039;tmp&#039;, biom_file_name);
  
  var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);

  var mapping_file_name = ts+&#039;_metadata.txt&#039;;
  var mapping_file = path.join(pwd,&#039;tmp&#039;, mapping_file_name);        
  var pc_file_name = ts+&#039;.pc&#039;;
  var pc_file = path.join(pwd,&#039;tmp&#039;, pc_file_name);
  //var tax_file_name = ts+&#039;_taxonomy.txt&#039;;
  //var tax_file = path.join(pwd,&#039;tmp&#039;, tax_file_name);
  var dist_file_name = ts+&#039;_distance.csv&#039;;
  var dist_file = path.join(pwd,&#039;tmp&#039;, dist_file_name);

  var dir_name = ts+&#039;_pcoa3d&#039;;
  var dir_path = path.join(pwd,&#039;views/tmp&#039;, dir_name);        
  var html_path = path.join(dir_path, &#039;index.html&#039;);  // file to be created by make_emperor.py script
  //var html_path2 = path.join(&#039;../&#039;,&#039;tmp&#039;, dir_name, &#039;index.html&#039;);  // file to be created by make_emperor.py script
  var options1 = {
    scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
    args :       [ &#039;-in&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;pcoa_3d&#039;, &#039;--outdir&#039;, path.join(pwd,&#039;tmp&#039;), &#039;--prefix&#039;, ts],
  };
  var options2 = {
      //scriptPath : req.CONFIG.PATH_TO_QIIME_BIN,
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ &#039;-i&#039;, pc_file, &#039;-m&#039;, mapping_file, &#039;-o&#039;, dir_path],
  };
  console.log(&#039;outdir: &#039;+dir_path);
  console.log(options1.scriptPath+&#039;/distance.py &#039;+options1.args.join(&#039; &#039;));
  

  var pcoa_process = spawn( options1.scriptPath+&#039;/distance.py&#039;, options1.args, {
      env:{ &#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH },
      detached: true, 
      stdio:[&#039;pipe&#039;, &#039;pipe&#039;, &#039;pipe&#039;]
      //stdio: [ &#039;ignore&#039;, null, log ]
        });  // stdin, stdout, stderr    
       
        pcoa_process.stdout.on(&#039;data&#039;, function (data) { console.log(&#039;1stdout: &#039; + data);  });
        stderr1=&#039;&#039;;
        pcoa_process.stderr.on(&#039;data&#039;, function (data) {
                console.log(&#039;1stderr-POST: &#039; + data);
                stderr1 += data; 
                //res.send(stderr1); 
                //return;              
        });
        pcoa_process.on(&#039;close&#039;, function (code1) {
                console.log(&#039;pcoa_process1 process exited with code &#039; + code1);
                
                if(code1 === 0){    // SUCCESS       
                    //console.log(options2.scriptPath+&#039;/make_emperor.py &#039;+options2.args.join(&#039; &#039;));
                    
                    //console.log(req.CONFIG.PATH)
                    //console.log(req.CONFIG.LD_LIBRARY_PATH)
                    //console.log(req.CONFIG.PYTHONPATH)
                    console.log(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;))
                    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
                    //var emperor_process = spawn( options2.scriptPath+&#039;/make_emperor.py&#039;, options2.args, {
                    var exec = require(&#039;child_process&#039;).exec;
                    cmd = options2.scriptPath+&#039;/make_emperor_custom.py&#039;
                    cmdline =  cmd+&#039; &#039;+options2.args.join(&#039; &#039;)
                    console.log(cmdline);
                    if(req.CONFIG.hostname.substring(0,6) == &#039;bpcweb&#039;){
                      var env = {&#039;PATH&#039;:req.CONFIG.PATH, &#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH, &#039;LAPACK&#039;:req.CONFIG.LAPACK};
                    }else{
                      var env = process.env;
                    }
                    // var env = process.env, envDup = {};
                    // for (someVar in env) {
                    //     envDup[someVar] = env[someVar];
                    // }
                    child = exec(cmdline, {
                              //cwd: req.CONFIG.PATH_TO_VIZ_SCRIPTS,
                              env : env                            
                            }, function (error, stdout, stderr) {

                      //console.log(&#039;stdout-POST: &#039; + stdout);

                      console.log(&#039;stderr-POST: &#039; + stderr);

                      if (error !== null) {

                        console.log(&#039;exec error-POST: &#039; + error);
                        var html = stderr
                        html += &quot;&lt;br&gt;Principal Components File: &lt;a href=&#039;/&quot;+pc_file_name+&quot;&#039;&gt;&quot;+pc_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Biom File: &lt;a href=&#039;/&quot;+biom_file_name+&quot;&#039;&gt;&quot;+biom_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Mapping (metadata) File: &lt;a href=&#039;/&quot;+mapping_file_name+&quot;&#039;&gt;&quot;+mapping_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Distance File: &lt;a href=&#039;/&quot;+dist_file_name+&quot;&#039;&gt;&quot;+dist_file_name+&quot;&lt;/a&gt;&quot;;
                        res.send(html); 
                        return; 

                      }else{
                       
                        var html = &quot;** &lt;a href=&#039;/tmp/&quot;+dir_name+&quot;/index&#039; target=&#039;_blank&#039;&gt;Open Emperor&lt;/a&gt; **&quot;
                        html += &quot;&lt;br&gt;Principal Components File: &lt;a href=&#039;/&quot;+pc_file_name+&quot;&#039;&gt;&quot;+pc_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Biom File: &lt;a href=&#039;/&quot;+biom_file_name+&quot;&#039;&gt;&quot;+biom_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Mapping (metadata) File: &lt;a href=&#039;/&quot;+mapping_file_name+&quot;&#039;&gt;&quot;+mapping_file_name+&quot;&lt;/a&gt;&quot;;
                        html += &quot;&lt;br&gt;Distance File: &lt;a href=&#039;/&quot;+dist_file_name+&quot;&#039;&gt;&quot;+dist_file_name+&quot;&lt;/a&gt;&quot;;
                        //html += &quot; &lt;a href=&#039;../tmp/&quot;+dir_name+&quot;/index&#039; target=&#039;_blank&#039;&gt;Emperor5&lt;/a&gt;&quot;

                        res.send(html); 
                        return;

                      }

                    });

                     
                }else{
                    //console.log(&#039;ERROR&#039;);
                    res.send(&#039;Python Script Error: &#039;+stderr1);
                }      
        });   
        /////////////////////////////////////////////////



});
// GET is to create and open EMPEROR
router.get(&#039;/pcoa3d&#039;, helpers.isLoggedIn, function(req, res) {
        
  console.log(&#039;in 3D&#039;);
  console.log(visual_post_items);
  var ts = visual_post_items.ts;    
  var metric = visual_post_items.selected_distance;
  
  var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
  var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
  var biom_file = path.join(pwd,&#039;tmp&#039;, biom_file_name);
  
  var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);

  var mapping_file_name = ts+&#039;_metadata.txt&#039;;
  var mapping_file = path.join(pwd,&#039;tmp&#039;, mapping_file_name);        
  var pc_file_name = ts+&#039;.pc&#039;;
  var pc_file = path.join(pwd,&#039;tmp&#039;, pc_file_name);
  
  var dir_name = ts+&#039;_pcoa3d&#039;;
  var dir_path = path.join(pwd,&#039;views/tmp&#039;, dir_name);        
  var html_path = path.join(dir_path, &#039;index.html&#039;);  // file to be created by make_emperor.py script
  //var html_path2 = path.join(&#039;../&#039;,&#039;tmp&#039;, dir_name, &#039;index.html&#039;);  // file to be created by make_emperor.py script
  var options1 = {
    scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
    args :       [ &#039;-i&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;pcoa_3d&#039;, &#039;--outdir&#039;, path.join(pwd,&#039;tmp&#039;), &#039;--prefix&#039;, ts],
  };
  var options2 = {
      //scriptPath : req.CONFIG.PATH_TO_QIIME_BIN,
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ &#039;-i&#039;, pc_file, &#039;-m&#039;, mapping_file, &#039;-o&#039;, dir_path],
  };
  console.log(&#039;outdir: &#039;+dir_path);
  console.log(options1.scriptPath+&#039;/distance.py &#039;+options1.args.join(&#039; &#039;));
  
  var pcoa_process = spawn( options1.scriptPath+&#039;/distance.py&#039;, options1.args, {
      env:{ &#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH },
      detached: true, 
      stdio:[&#039;pipe&#039;, &#039;pipe&#039;, &#039;pipe&#039;]
      //stdio: [ &#039;ignore&#039;, null, log ]
        });  // stdin, stdout, stderr1    
       
        pcoa_process.stdout.on(&#039;data&#039;, function (data) { console.log(&#039;1stdout: &#039; + data);  });
        stderr1=&#039;&#039;;
        pcoa_process.stderr1.on(&#039;data&#039;, function (data) {
                console.log(&#039;1stderr-GET: &#039; + data);
                stderr1 += data;               
        });
        pcoa_process.on(&#039;close&#039;, function (code1) {
                console.log(&#039;pcoa_process1 process exited with code &#039; + code1);
                
                if(code1 === 0){    // SUCCESS       
                    //console.log(options2.scriptPath+&#039;/make_emperor.py &#039;+options2.args.join(&#039; &#039;));
                    
                    //console.log(req.CONFIG.PATH)
                    //console.log(req.CONFIG.LD_LIBRARY_PATH)
                    //console.log(req.CONFIG.PYTHONPATH)
                    console.log(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;))
                    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
                    //var emperor_process = spawn( options2.scriptPath+&#039;/make_emperor.py&#039;, options2.args, {
                    var exec = require(&#039;child_process&#039;).exec;
                    cmd = options2.scriptPath+&#039;/make_emperor_custom.py&#039;
                    cmdline =  cmd+&#039; &#039;+options2.args.join(&#039; &#039;)
                    console.log(cmdline);
                    if(req.CONFIG.hostname.substring(0,6) == &#039;bpcweb&#039;){
                      var env = {&#039;PATH&#039;:req.CONFIG.PATH, &#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH, &#039;LAPACK&#039;:req.CONFIG.LAPACK};
                    }else{
                      var env = process.env;
                    }
                    // var env = process.env, envDup = {};
                    // for (someVar in env) {
                    //     envDup[someVar] = env[someVar];
                    // }
                    child = exec(cmdline, {
                              //cwd: req.CONFIG.PATH_TO_VIZ_SCRIPTS,
                              env : env                            
                            }, function (error, stdout, stderr) {

                      //console.log(&#039;stdout-GET: &#039; + stdout);

                      console.log(&#039;stderr-GET: &#039; + stderr);

                      if (error !== null) {

                        console.log(&#039;exec error-GET: &#039; + error);
                        

                      }else{
                        //res.sendFile(&#039;tmp/&#039;+dir_name+&#039;/index.html&#039;, {root:pwd});
                        //open(&#039;file://&#039;+html_path);
                        //res.send(&quot;Done - &lt;a href=&#039;https://github.com/biocore/emperor&#039; target=&#039;_blank&#039;&gt;Emperor&lt;/a&gt; will open a new window in your default browser.&quot;); 
                        //res.send(&quot;Done - &lt;a href=&#039;/tmp/&quot;+dir_name+&quot;/index.html&#039; target=&#039;_blank&#039;&gt;Emperor&lt;/a&gt; will open a new window in your default browser.&quot;); 
                        //html = &quot;&lt;a href=&#039;../tmp/andy_1450362333240_pcoa3d/index&#039; target=&#039;_blank&#039;&gt;Emperor1&lt;/a&gt;&quot;
                        html = &quot; &lt;a href=&#039;/tmp/&quot;+dir_name+&quot;/index&#039; target=&#039;_blank&#039;&gt;Emperor&lt;/a&gt;&quot;
                        //html += &quot; &lt;a href=&#039;../tmp/&quot;+dir_name+&quot;/index&#039; target=&#039;_blank&#039;&gt;Emperor5&lt;/a&gt;&quot;

                        res.send(html); 

                      }

                    });

                    // var emperor_process = exec( &#039;make_emperor.py&#039;, options2.args, {
                    //         env:{ &#039;PATH&#039;:req.CONFIG.PATH, &#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH, &#039;PYTHONPATH&#039;:req.CONFIG.PYTHONPATH},
                    //         //detached: true, 
                    //         detached: false,
                    //         stdio:&#039;pipe&#039; // stdin, stdout, stderr
                    //         //stdio: [ &#039;ignore&#039;, log, log ]
                    // });  
                    
                    // emperor_process.stdout.on(&#039;data&#039;, function (data) { 
                    //   console.log(&#039;2stdout: &#039; + data);  
                    // });
                    // stderr2=&#039;&#039;;
                    // emperor_process.stderr.on(&#039;data&#039;, function (data) {
                    //         console.log(&#039;2stderr: &#039; + data);
                    //         stderr2 += data;                       
                    // });
                    // emperor_process.on(&#039;close&#039;, function (code2) {
                    //       console.log(&#039;emperor_process process exited with code &#039; + code2);
                          
                    //       if(code2 === 0){           
                              
                    //           console.log(&#039;opening file:///&#039;+html_path);
                    //           //res.send();
                    //           res.sendFile(&#039;tmp/&#039;+dir_name+&#039;/index.html&#039;, {root:pwd});

                    //           //open(&#039;file://&#039;+html_path);
                    //           //res.send(ok_form+&quot;Done - &lt;a href=&#039;https://github.com/biocore/emperor&#039; target=&#039;_blank&#039;&gt;Emperor&lt;/a&gt; will open a new window in your default browser.&quot;); 
                    //       }else{
                    //         // python script error
                    //         //console.log(&#039;make_emperor script error:&#039; + errdata2);
                    //         res.send(&#039;make_emperor2 SCRIPT error &#039;+stderr2);
                    //       }      
                    // });                      
                }else{
                    //console.log(&#039;ERROR&#039;);
                    res.send(&#039;Python Script Error: &#039;+stderr1);
                }      
        });   
        

});

//
// DATA BROWSER 
//
router.get(&#039;/dbrowser&#039;, helpers.isLoggedIn, function(req, res) {
    var ts = visual_post_items.ts;
    console.log(&#039;in dbrowser&#039;);
    //console.log(JSON.stringify(BIOM_MATRIX,null,2));
    var html=&#039;&#039;;
    var max_total_count = Math.max.apply(null, BIOM_MATRIX.column_totals);
    //console.log(&#039;column_totals &#039;+BIOM_MATRIX.column_totals);
    //console.log(&#039;max_total_count &#039;+max_total_count.toString());

    // sum counts
    sumator = get_sumator(req);
 
    //console.log(JSON.stringify(sumator))
    
    for(var d in sumator[&#039;domain&#039;]){
        
      // #### DOMAIN ####
      //var dnode_name =  dname
      html += &quot;&lt;node name=&#039;&quot;+d+&quot;&#039;&gt;\n&quot;;
      html += &quot; &lt;seqcount&gt;&quot;;
      for(var c_domain in sumator[&#039;domain&#039;][d][&#039;knt&#039;]){
          html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;knt&#039;][c_domain].toString()+&quot;&lt;/val&gt;&quot;;
      }
        html += &quot;&lt;/seqcount&gt;\n&quot;;
        html += &quot; &lt;rank&gt;&lt;val&gt;domain&lt;/val&gt;&lt;/rank&gt;\n&quot;;
        
        // #### PHYLUM ####
        for(p in sumator[&#039;domain&#039;][d][&#039;phylum&#039;]){              
          html += &quot; &lt;node name=&#039;&quot;+p+&quot;&#039;&gt;\n&quot;;
          html += &quot;  &lt;seqcount&gt;&quot;;
          for(c_phylum in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;]){
              html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;][c_phylum].toString()+&quot;&lt;/val&gt;&quot;;
          }
            html += &quot;&lt;/seqcount&gt;\n&quot;;
            html += &quot;  &lt;rank&gt;&lt;val&gt;phylum&lt;/val&gt;&lt;/rank&gt;\n&quot;;
///            
            // #### KLASS ####
            for(k in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;]){                
                html += &quot;  &lt;node name=&#039;&quot;+k+&quot;&#039;&gt;\n&quot;;
                html += &quot;   &lt;seqcount&gt;&quot;;
                for(c_klass in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;]){
                    html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;][c_klass].toString()+&quot;&lt;/val&gt;&quot;;
                }
                html += &quot;&lt;/seqcount&gt;\n&quot;;
                html += &quot;   &lt;rank&gt;&lt;val&gt;klass&lt;/val&gt;&lt;/rank&gt;\n&quot;;

                // #### ORDER ####
                for(o in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;]){                    
                    html += &quot;   &lt;node name=&#039;&quot;+o+&quot;&#039;&gt;\n&quot;;
                    html += &quot;    &lt;seqcount&gt;&quot;;
                    for(c_order in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;]){
                        html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;][c_order].toString()+&quot;&lt;/val&gt;&quot;;
                    }
                    html += &quot;&lt;/seqcount&gt;\n&quot;;
                    html += &quot;    &lt;rank&gt;&lt;val&gt;order&lt;/val&gt;&lt;/rank&gt;\n&quot;;

                    // #### FAMILY ####
                    for(f in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;]){                        
                        html += &quot;    &lt;node name=&#039;&quot;+f+&quot;&#039;&gt;\n&quot;;
                        html += &quot;     &lt;seqcount&gt;&quot;;
                        for(c_family in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;]){
                            html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;][c_family].toString()+&quot;&lt;/val&gt;&quot;;
                        }
                        html += &quot;&lt;/seqcount&gt;\n&quot;;
                        html += &quot;     &lt;rank&gt;&lt;val&gt;family&lt;/val&gt;&lt;/rank&gt;\n&quot;;

                        // #### GENUS ####
                        for(g in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;]){                           
                            html += &quot;     &lt;node name=&#039;&quot;+g+&quot;&#039;&gt;\n&quot;;
                            html += &quot;      &lt;seqcount&gt;&quot;;
                            for(c_genus in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;]){
                                html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;][c_genus].toString()+&quot;&lt;/val&gt;&quot;;
                            }
                            html += &quot;&lt;/seqcount&gt;\n&quot;;
                            html += &quot;      &lt;rank&gt;&lt;val&gt;genus&lt;/val&gt;&lt;/rank&gt;\n&quot;;

                            // #### SPECIES ####
                            for(s in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;]){                            
                                html += &quot;     &lt;node name=&#039;&quot;+s+&quot;&#039;&gt;\n&quot;;
                                html += &quot;      &lt;seqcount&gt;&quot;;
                                for(c_species in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;]){
                                    html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;][c_species].toString()+&quot;&lt;/val&gt;&quot;;
                                }
                                html += &quot;&lt;/seqcount&gt;\n&quot;;
                                html += &quot;      &lt;rank&gt;&lt;val&gt;species&lt;/val&gt;&lt;/rank&gt;\n&quot;;
                                
                                // #### STRAIN ####
                                for(st in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;]){                            
                                      html += &quot;     &lt;node name=&#039;&quot;+st+&quot;&#039;&gt;\n&quot;;
                                      html += &quot;      &lt;seqcount&gt;&quot;;
                                      for(c_strain in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;]){
                                          html += &quot;&lt;val&gt;&quot;+sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;][c_strain].toString()+&quot;&lt;/val&gt;&quot;;
                                      }
                                      html += &quot;&lt;/seqcount&gt;\n&quot;;
                                      html += &quot;      &lt;rank&gt;&lt;val&gt;strain&lt;/val&gt;&lt;/rank&gt;\n&quot;;
 ///// DONE //////
                                      html += &quot;     &lt;/node&gt;\n&quot;;
                                }  // end strain

                                html += &quot;     &lt;/node&gt;\n&quot;;
                            }  // end species
       

                            html += &quot;     &lt;/node&gt;\n&quot;;
                        }  // end genus
                        html += &quot;    &lt;/node&gt;\n&quot;;
                    }  // end family
                    html += &quot;   &lt;/node&gt;\n&quot;;
                }  // end order
                html += &quot;  &lt;/node&gt;\n&quot;;
            }  // end klass
            html += &quot; &lt;/node&gt;\n&quot;;
        }  // end phylum
        html += &quot;&lt;/node&gt;\n&quot;;
    }    // end domain
    html += &quot;  &lt;/node&gt;\n&quot;;
    
    
    // write html to a file and open it 
    
    console.log(&quot;render visuals/dbrowser&quot;)
    //var file_name = ts+&#039;_krona.html&#039;;
    //var html_path = path.join(process.env.PWD,&#039;tmp&#039;, file_name);

    res.render(&#039;visuals/dbrowser&#039;, {        
      title: &#039;VAMPS:Taxonomy Browser (Krona)&#039;,
      message:             req.flash(&#039;message&#039;),
      user:                req.user,
      html:                html,
      max_total_count:     max_total_count,
      matrix:              JSON.stringify(BIOM_MATRIX),
      chosen_id_name_hash: JSON.stringify(chosen_id_name_hash)            

    });

    
});
//
//
//
router.post(&#039;/alpha_diversity&#039;, helpers.isLoggedIn, function(req, res) {
    console.log(&#039;in alpha div&#039;)
    var ts = req.body.ts;
    var metric = req.body.metric;
    var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
    var biom_file = path.join(process.env.PWD,&#039;tmp&#039;, biom_file_name);
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    
    var html = &#039;&#039;;
    var title = &#039;VAMPS&#039;;
    console.log(biom_file)
    //var distmtx_file_name = ts+&#039;_distance.csv&#039;;
    //var distmtx_file = path.join(process.env.PWD,&#039;tmp&#039;,distmtx_file_name);
   
    var options = {
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ &#039;-in&#039;, biom_file, &#039;--site_base&#039;, process.env.PWD, &#039;--prefix&#039;, ts],
    };

   
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    // script will remove data from mysql and datset taxfile
    console.log(options.scriptPath+&#039;alpha_diversity.py &#039;+options.args.join(&#039; &#039;));
    var alphadiv_process = spawn( options.scriptPath+&#039;/alpha_diversity.py&#039;, options.args, {
                env:{&#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH},
                detached: true, 
                //stdio:[&#039;pipe&#039;, &#039;pipe&#039;, log]
                //stdio:  log 
                stdio: &#039;pipe&#039;  // stdin, stdout, stderr
            }); 
    
    stdout = &#039;&#039;;
    alphadiv_process.stdout.on(&#039;data&#039;, function (data) {
        data = data.toString();
        console.log(data)
        stdout += data;    
     
    });
    stderr = &#039;&#039;;
    alphadiv_process.stderr.on(&#039;data&#039;, function (data) {
        data = data.toString();
        console.log(data)
        stderr += data;    
     
    });
    alphadiv_process.on(&#039;close&#039;, function (code) {
        console.log(&#039;alphadiv_process process exited with code &#039; + code);
        if(code == 0){           
            res.send(stdout);                                 
        }else{
          console.log(&#039;python script error: &#039;+stderr);
          res.send(stderr); 
        }      
    });   


});
//
//
//
router.post(&#039;/phyloseq&#039;, helpers.isLoggedIn, function(req, res) {
    console.log(&#039;in phyloseq post&#039;)
    //console.log(req.body)

    var ts = req.body.ts;
    var rando = Math.floor((Math.random() * 100000) + 1);  // required to prevent image caching
    var dist_metric = req.body.metric;
    var plot_type = req.body.plot_type;
    var image_file = ts+&#039;_phyloseq_&#039;+plot_type+&#039;_&#039;+rando.toString()+&#039;.svg&#039;;
    var phy,md1,md2,ordtype,maxdist,script
    
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    var fill = visual_post_items.tax_depth.charAt(0).toUpperCase() + visual_post_items.tax_depth.slice(1);
    if(fill === &#039;Klass&#039;){
        fill = &#039;Class&#039;;
    }
    var tmp_path = path.join(process.env.PWD,&#039;tmp&#039;);
    var html = &#039;&#039;;
    //console.log(biom_file)
    var options = {
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ tmp_path, ts ],
    };
    if(plot_type == &#039;bar&#039;){
      script = &#039;phyloseq_bar.R&#039;;
      phy = req.body.phy;
      options.args = options.args.concat([image_file, phy, fill]);
    }else if(plot_type == &#039;heatmap&#039;){
      script = &#039;phyloseq_heatmap.R&#039;;
      //image_file = ts+&#039;_phyloseq_&#039;+plot_type+&#039;_&#039;+rando.toString()+&#039;.png&#039;;
      phy = req.body.phy;
      md1 = req.body.md1;
      ordtype = req.body.ordtype;
      options.args = options.args.concat([image_file, dist_metric, phy, md1, ordtype, fill]);
    }else if(plot_type == &#039;network&#039;){
      script = &#039;phyloseq_network.R&#039;;
      md1 = req.body.md1 || &quot;Project&quot;;
      md2 = req.body.md2 || &quot;Description&quot;;
      maxdist = req.body.maxdist || &quot;0.3&quot;;
      options.args = options.args.concat([image_file, dist_metric, md1, md2, maxdist]);
    }else if(plot_type == &#039;ord&#039;){
      script = &#039;phyloseq_ord.R&#039;;
      md1 = req.body.md1 || &quot;Project&quot;;
      md2 = req.body.md2 || &quot;Description&quot;;
      ordtype = req.body.ordtype || &quot;PCoA&quot;;
      options.args = options.args.concat([image_file, dist_metric, md1, md2, ordtype]);
    }else if(plot_type == &#039;tree&#039;){
      script = &#039;phyloseq_tree.R&#039;;
      md1 = req.body.md1 || &quot;Description&quot;;
      options.args = options.args.concat([image_file, dist_metric, md1]);
    }else{
      //ERROR
    }
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    
    console.log(options.scriptPath+script+&#039; &#039;+options.args.join(&#039; &#039;));
    var phyloseq_process = spawn( options.scriptPath+script, options.args, {
            env:{&#039;PATH&#039;:req.CONFIG.PATH},
            detached: true, 
            //stdio: [ &#039;ignore&#039;, null, log ]
            stdio: &#039;pipe&#039;  // stdin, stdout, stderr
    }); 
    stdout = &#039;&#039;;
    lastline=&#039;&#039;;
    phyloseq_process.stdout.on(&#039;data&#039;, function (data) {
        lastline = data;
        stdout += data;      
    });
    stderr = &#039;&#039;;
    phyloseq_process.stderr.on(&#039;data&#039;, function (data) {
        stderr += data;      
    }); 
    phyloseq_process.on(&#039;close&#039;, function (code) {
          console.log(&#039;phyloseq_process process exited with code &#039; + code);
          //distance_matrix = JSON.parse(output);
          //var last_line = ary[ary.length - 1];
          if(code === 0){   // SUCCESS
            console.log(&#039;last: &#039;+lastline);
            if(lastline.toString().substring(0,5) == &#039;ERROR&#039;){
                    console.log(&#039;ERROR-1&#039;); 
                    html = lastline;                   
            }else{                  
                
              //   var image = &#039;/&#039;+ts+&#039;_heatmap.pdf&#039;;
              // //console.log(image)
              // html = &quot;&lt;div id=&#039;pdf&#039;&gt;&quot;;
              // html += &quot;&lt;object data=&#039;&quot;+image+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039; width=&#039;100%&#039; height=&#039;700&#039; /&gt;&quot;;
              // html += &quot; &lt;p&gt;ERROR in loading pdf file&lt;/p&gt;&quot;;
              // html += &quot;&lt;/object&gt;&lt;/div&gt;&quot;;
              // res.send(html);

              // return;

                 
                 if(plot_type == &#039;heatmap&#039;){   // for some unknown reason heatmaps are different: use pdf not svg
                 //html = &quot;&lt;object  data=&#039;/&quot;+image_file+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039;width=&#039;100%&#039; height=&#039;700&#039; &gt;Your browser does not support SVG&lt;/object&gt;&quot;;
                      html = &quot;&lt;div id=&#039;pdf&#039;&gt;&quot;;
                      html += &quot;&lt;object data=&#039;/&quot;+image_file+&quot;?zoom=100&amp;scrollbar=0&amp;toolbar=0&amp;navpanes=0&#039; type=&#039;application/pdf&#039; width=&#039;100%&#039; height=&#039;700&#039; /&gt;&quot;;
                      html += &quot; &lt;p&gt;ERROR in loading pdf file&lt;/p&gt;&quot;;
                      html += &quot;&lt;/object&gt;&lt;/div&gt;&quot;; 
                 }else{
                      html = &quot;&lt;img src=&#039;/&quot;+image_file+&quot;&#039;  &gt;&quot;;                    
                }              
            }

          }else{
            console.log(&#039;ERROR-2&#039;);            
            html = &quot;Phyloseq Error: Try selecting more data, deeper taxonomy or excluding &#039;NA&#039;s&quot;
          } 
          console.log(html);
          res.send(html);

    });   

});

//
//  for alpha diversity
//
function get_sumator(req){
    
    var sumator = {};
    sumator[&#039;domain&#039;]={};
    var did = chosen_id_name_hash.ids[i];
    var dname = chosen_id_name_hash.names[i];
    
    for(r in BIOM_MATRIX.rows){
        tax_string = BIOM_MATRIX.rows[r].id;
        tax_items = tax_string.split(&#039;;&#039;);
        key = tax_items[0];
        //console.log(tax_items);
        for(t in tax_items){
           var taxa = tax_items[t];
           var rank = req.CONSTS.RANKS[t];
           if(rank==&#039;domain&#039;){
               d = tax_items[t]
               for(i in chosen_id_name_hash.ids){
                   if(d in sumator[&#039;domain&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]); 
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                       } 
                   }else{
                       sumator[&#039;domain&#039;][d]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;]={}
                       sumator[&#039;domain&#039;][d][&#039;knt&#039;]=[] 
                       sumator[&#039;domain&#039;][d][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);  
                   }
               }
           }
           if(rank==&#039;phylum&#039;){
               p = tax_items[t]
               for(i in chosen_id_name_hash.ids){
                   if(p in sumator[&#039;domain&#039;][d][&#039;phylum&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }
           if(rank==&#039;klass&#039;){
               k = tax_items[t]
               for(i in chosen_id_name_hash.ids){
                   if(k in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }
           if(rank==&#039;order&#039;){
               o = tax_items[t]
               for(i in chosen_id_name_hash.ids){
                   if(o in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }
           if(rank==&#039;family&#039;){
               f = tax_items[t]
               for(i in chosen_id_name_hash.ids){
                   if(f in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }
           if(rank==&#039;genus&#039;){
               g = tax_items[t]
               for(i in chosen_id_name_hash.ids){                   
                   if(g in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }

           if(rank==&#039;species&#039;){
               s = tax_items[t]
               for(i in chosen_id_name_hash.ids){                   
                   if(s in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s]={};

                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }
           if(rank==&#039;strain&#039;){
               st = tax_items[t]
               for(i in chosen_id_name_hash.ids){                   
                   if(st in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;]){
                       if(i in sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;]){
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;][i] += parseInt(BIOM_MATRIX.data[r][i]);
                       }else{
                           sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]);
                       }
                   }else{
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st]={};
                       //sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;]={};
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;]=[];
                       sumator[&#039;domain&#039;][d][&#039;phylum&#039;][p][&#039;klass&#039;][k][&#039;order&#039;][o][&#039;family&#039;][f][&#039;genus&#039;][g][&#039;species&#039;][s][&#039;strain&#039;][st][&#039;knt&#039;][i] = parseInt(BIOM_MATRIX.data[r][i]); 
                   }
               }
           }


        }
    }
    return sumator;
}



//
//  G E O S P A T I A L (see view_selection.js)
//


//
// B A R - C H A R T  -- S I N G L E
//
router.get(&#039;/bar_single&#039;, helpers.isLoggedIn, function(req, res) {
    var myurl = url.parse(req.url, true);
    //console.log(&#039;in piechart_single&#039;+myurl)
    var ts = myurl.query.ts;
    var pjds = myurl.query.id;
    var ds_items = pjds.split(&#039;--&#039;);

    //var html  = COMMON.start_visuals_html(&#039;piechart&#039;);
    //var html  = &#039;My HTML&#039;;
    var selected_did = chosen_id_name_hash.ids[chosen_id_name_hash.names.indexOf(pjds)]
    var new_matrix={}
    new_matrix.rows = BIOM_MATRIX.rows;
    new_matrix.columns =[];
    new_matrix.dataset = pjds;
    //new_matrix.dids = [chosen_id_name_hash.ids[chosen_id_name_hash.names.indexOf(pjds)]];
    new_matrix.data = []
    new_matrix.total = 0
    new_matrix.shape = [BIOM_MATRIX.shape[0],1]
    var idx = -1;

    for(d in BIOM_MATRIX.columns){
      if(BIOM_MATRIX.columns[d].id == pjds){
      	//console.log(&#039;found idx &#039;+BIOM_MATRIX.columns[d].name)
      	idx = d;
      	new_matrix.columns.push(BIOM_MATRIX.columns[d]);
      	//new_matrix.columns.push({&quot;name&quot;:ds_name,&quot;did&quot;:did});
      	break;
      }
    }

    for(n in BIOM_MATRIX.data){
      new_matrix.data.push([BIOM_MATRIX.data[n][d]])
      new_matrix.total += BIOM_MATRIX.data[n][d]
    }
    //console.log(JSON.stringify(new_matrix))
    var timestamp = +new Date();  // millisecs since the epoch!  
    var filename = req.user.username+&#039;_&#039;+selected_did+&#039;_&#039;+timestamp+&#039;_sequences.json&#039;
    var file_path = path.join(&#039;tmp&#039;,filename);
    //console.log(file_path)
    new_rows = {}
    new_rows[selected_did] = []
    connection.query(QUERY.get_sequences_perDID([selected_did]), function(err, rows, fields){
        if (err)  {
          console.log(&#039;Query error: &#039; + err);
          console.log(err.stack);
          res.send(err)
        } else {
          //console.log(rows)
          for(s in rows){
              //rows[s].seq = rows[s].seq.toString(&#039;utf8&#039;)
              did = rows[s].dataset_id
              
              var seq = rows[s].seq.toString(&#039;utf8&#039;);
              var seq_cnt = rows[s].seq_count;
              var gast = rows[s].gast_distance
              var classifier = rows[s].classifier
              var d_id = rows[s].domain_id
              var p_id = rows[s].phylum_id
              var k_id = rows[s].klass_id
              var o_id = rows[s].order_id
              var f_id = rows[s].family_id
              var g_id
              if(rows[s].hasOwnProperty(&quot;genus_id&quot;)){
                if(rows[s].genus_id == &#039;undefined&#039;){
                    g_id = &#039;genus_NA&#039;
                }else{
                    g_id = rows[s].genus_id
                }
                
              }else{
                g_id = &#039;&#039;
              }
              
              
              if(rows[s].hasOwnProperty(&quot;species_id&quot;)){
                var sp_id = rows[s].species_id
              }else{
                var sp_id = &#039;&#039;
              }
              var st_id = rows[s].strain_id
              new_rows[did].push({seq:seq,seq_count:seq_cnt,gast_distance:gast,classifier:classifier,domain_id:d_id,phylum_id:p_id,klass_id:k_id,order_id:o_id,family_id:f_id,genus_id:g_id,species_id:sp_id,strain_id:st_id})

          }
          // order by seq_count DESC
          new_rows[selected_did].sort(function(a, b) {
            return b.seq_count - a.seq_count;
          });
          //fs.writeFile(file_path, JSON.stringify(new_rows[selected_did]), function (err) {
          //  if (err) return console.log(err);
          //  console.log(&#039;wrote to &gt; &#039;+file_path);
          //});
          fs.writeFileSync(file_path, JSON.stringify(new_rows[selected_did]))
          res.render(&#039;visuals/user_viz_data/bar_single&#039;, {
              title: &#039;Taxonomic Data&#039;,
              ts: ts || &#039;default_timestamp&#039;,
              matrix    :           JSON.stringify(new_matrix),
              post_items:           JSON.stringify(visual_post_items),
              seqs_file : filename,
              bar_type  : &#039;single&#039;,
              //html: html,
              user: req.user, hostname: req.CONFIG.hostname,
          });

        }
    })
  	
//console.log(new_matrix)
    // res.render(&#039;visuals/user_viz_data/bar_single&#039;, {
    //     title: &#039;Taxonomic Data&#039;,
    //     ts: ts || &#039;default_timestamp&#039;,
  		//   matrix    :           JSON.stringify(new_matrix),
  		//   post_items:           JSON.stringify(visual_post_items),
    //     seqs_file : filename,
    //     bar_type  : &#039;single&#039;,
    //     //html: html,
    //     user: req.user, hostname: req.CONFIG.hostname,
    // });

});

// router.post(&#039;visuals/fileUpload&#039;, function(req, res) {
//     console.log(&#039;in fileUPLOAD&#039;)
//     // http://www.iamrohit.in/file-upload-in-nodejs-with-progress-bar/
//     var tempPath = req.files.uploadfile.path;
//     var targetPath = config.UPLOADDIR+req.files.uploadfile.name;
//     fs.rename(tempPath, targetPath, function(err) {
//       if(err) {
//         //res.send(&quot;Error found to upload file &quot;+err);
//         var msg = &quot;Error found to upload file &quot;+err;
//         var type=&quot;error&quot;;
//       } else {
//         //res.send(&quot;&lt;b&gt;File uploaded to &quot;+targetPath+&quot; (&quot;+req.files.uploadfile.size +&quot; bytes)&lt;/b&gt;&quot;);
//         var fileSize = req.files.uploadfile.size/1024;
//         var msg = &quot;File uploaded to &quot;+targetPath+&quot; (&quot;+(fileSize.toFixed(2)) +&quot; kb)&quot;;
//         var type=&quot;success&quot;;
//         res.send(req.files.uploadfile.name);
//       }
//     });
// });
//
// B A R - C H A R T  -- D O U B L E
//
router.get(&#039;/bar_double&#039;, helpers.isLoggedIn, function(req, res) {
    
    var myurl = url.parse(req.url, true);
    var did1 = myurl.query.did1;
    var did2 = myurl.query.did2;
    var ts   = myurl.query.ts;
    var ds1  = chosen_id_name_hash.names[chosen_id_name_hash.ids.indexOf(did1)]
    var ds2  = chosen_id_name_hash.names[chosen_id_name_hash.ids.indexOf(did2)]
    //var ds_items = pjds.split(&#039;--&#039;);
    
    
    //var html  = &#039;My HTML&#039;;
    
    var new_matrix={}
    new_matrix.rows = BIOM_MATRIX.rows;   // taxonomy
    new_matrix.columns =[];
    new_matrix.datasets = [ds1,ds2];
    //new_matrix.dids = [did1,did2];
    
    new_matrix.data = []
    for(n in BIOM_MATRIX.rows){
      new_matrix.data.push([])
    }
    new_matrix.column_totals = [0,0]
    //console.log(&#039;3&#039;)
    new_matrix.shape = [BIOM_MATRIX.shape[0],2]
    var idx1 = -1;
    var idx2 = -1;
    //console.log(&#039;4&#039;)
    // datasets
    for(d in BIOM_MATRIX.columns){
      if(BIOM_MATRIX.columns[d].id == ds1){
        idx1 = d;
        //new_matrix.columns.push(BIOM_MATRIX.columns[d]);        
      }
      if(BIOM_MATRIX.columns[d].id == ds2){
        idx2 = d;
        //new_matrix.columns.push(BIOM_MATRIX.columns[d]);        
      }
    }
    new_matrix.columns.push(BIOM_MATRIX.columns[idx1]);
    new_matrix.columns.push(BIOM_MATRIX.columns[idx2]);    
    //console.log(&#039;5&#039;)
    for(n in BIOM_MATRIX.rows){ // one item for each of two columns (datasets)
      new_matrix.data[n].push(BIOM_MATRIX.data[n][idx1])
      new_matrix.data[n].push(BIOM_MATRIX.data[n][idx2])
      
    }
    for(n in BIOM_MATRIX.data){ // one item for each column
      
      new_matrix.column_totals[0] += BIOM_MATRIX.data[n][idx1]

      //new_matrix.data[1].push(BIOM_MATRIX.data[n][idx2])
      new_matrix.column_totals[1] += BIOM_MATRIX.data[n][idx2]
    }
    //console.log(JSON.stringify(new_matrix))
    //console.log(chosen_id_name_hash)
    //open(&#039;views/visuals/user_viz_data/bar_double.html&#039;);
    var timestamp = +new Date();  // millisecs since the epoch!  
    var filename1 = req.user.username+&#039;_&#039;+did1+&#039;_&#039;+timestamp+&#039;_sequences.json&#039;
    var file_path1 = path.join(&#039;tmp&#039;,filename1);
    var filename2 = req.user.username+&#039;_&#039;+did2+&#039;_&#039;+timestamp+&#039;_sequences.json&#039;
    var file_path2 = path.join(&#039;tmp&#039;,filename2);
    //console.log(file_path)
    new_rows = {}
    new_rows[did1] = []
    new_rows[did2] = []
    //console.log(new_rows)
    connection.query(QUERY.get_sequences_perDID(did1+&quot;&#039;,&#039;&quot;+did2), function(err, rows, fields){
        if (err)  {
          console.log(&#039;Query error: &#039; + err);
          console.log(err.stack);
          res.send(err)
        } else {
          //console.log(rows)
          // should write to a file? Or res.render here?

          for(s in rows){
              did = rows[s].dataset_id
              
              //console.log(did)
              //rows[s].seq = rows[s].seq.toString(&#039;utf8&#039;)
              var seq = rows[s].seq.toString(&#039;utf8&#039;);
              var seq_cnt = rows[s].seq_count;
              var gast = rows[s].gast_distance
              var classifier = rows[s].classifier
              var d_id = rows[s].domain_id
              var p_id = rows[s].phylum_id
              var k_id = rows[s].klass_id
              var o_id = rows[s].order_id
              var f_id = rows[s].family_id
              var g_id = rows[s].genus_id
              var sp_id = rows[s].species_id
              var st_id = rows[s].strain_id
              new_rows[did].push({seq:seq,seq_count:seq_cnt,gast_distance:gast,classifier:classifier,domain_id:d_id,phylum_id:p_id,klass_id:k_id,order_id:o_id,family_id:f_id,genus_id:g_id,species_id:sp_id,strain_id:st_id})
              //new_rows[did].seq = rows[s].seq.toString(&#039;utf8&#039;)
          }
          // order by seq_count DESC
          //console.log(new_rows)
          new_rows[did1].sort(function(a, b) {
            return b.seq_count - a.seq_count;
          });
          new_rows[did2].sort(function(a, b) {
                  return b.seq_count - a.seq_count;
          });

          fs.writeFile(file_path1, JSON.stringify(new_rows[did1]), function (err) {
            if (err) return console.log(err);
            console.log(&#039;wrote file &gt; &#039;+file_path1);

         
            fs.writeFile(file_path2, JSON.stringify(new_rows[did2]), function (err) {
              if (err) return console.log(err);
              console.log(&#039;wrote file &gt; &#039;+file_path2);
              res.render(&#039;visuals/user_viz_data/bar_double&#039;, {
                  title: &#039;Taxonomic Data&#039;,
                  ts: timestamp,
                  matrix    :           JSON.stringify(new_matrix),
                  post_items:           JSON.stringify(visual_post_items),
                  bar_type  : &#039;double&#039;,        
                  //html: html,
                  user: req.user, hostname: req.CONFIG.hostname,
              });
            });

          });

        }
    })
    //console.log(new_matrix)
    // res.render(&#039;visuals/user_viz_data/bar_double&#039;, {
    //     title: &#039;Taxonomic Data&#039;,
    //     ts: timestamp,
    //     matrix    :           JSON.stringify(new_matrix),
    //     post_items:           JSON.stringify(visual_post_items),
    //     bar_type  : &#039;double&#039;,        
    //     //html: html,
    //     user: req.user, hostname: req.CONFIG.hostname,
    // });

});
//
//  S E Q U E N C E S
//
router.get(&#039;/sequences/&#039;, helpers.isLoggedIn, function(req, res) {
	console.log(&#039;in sequences&#039;)
	var myurl = url.parse(req.url, true);
	var search_tax = myurl.query.taxa;
  var seqs_filename = myurl.query.filename;
    
	var pjds = myurl.query.id;
    var seq_list = [];
    var d,p,k,o,f,g,sp,st;
    var selected_did = chosen_id_name_hash.ids[chosen_id_name_hash.names.indexOf(pjds)];
	if(seqs_filename){
    //console.log(&#039;found filename&#039;,seqs_filename)
    
    fs.readFile(path.join(&#039;tmp&#039;,seqs_filename), &#039;utf8&#039;, function (err,data) {
      if (err) {
        console.log(err);
        res.send(&#039;No file found: &#039;+seqs_filename+&quot;; Use the browsers &#039;Back&#039; button and try again&quot;)
      }
      //console.log(&#039;parsing data&#039;)
      try{
        var clean_data = JSON.parse(data)
      }catch(e){
        console.log(e);
        res.render(&#039;visuals/user_viz_data/sequences&#039;, {
                    title: &#039;Sequences&#039;,
                    ds : pjds,
                    tax : search_tax,
                    fname : seqs_filename,
                    seq_list : &#039;Error Retrieving Sequences&#039;,
                    user: req.user, hostname: req.CONFIG.hostname,
        });
        return
      }
      
      for(i in clean_data){
        
          seq_tax = &#039;&#039;
          var data = clean_data[i]
          
          d  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.domain_id+&quot;_domain&quot;].taxon;
          
          try{
                p  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.phylum_id+&quot;_phylum&quot;].taxon;
          }catch(e){
                p = &#039;phylum_NA&#039;
          }
          try{
                k  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.klass_id+&quot;_klass&quot;].taxon;
          }catch(e){
                k = &#039;class_NA&#039;
          }
          try{
                o  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.order_id+&quot;_order&quot;].taxon;
          }catch(e){
                o = &#039;order_NA&#039;
          }
          try{
                f  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.family_id+&quot;_family&quot;].taxon;
          }catch(e){
                f = &#039;family_NA&#039;
          }
          try{
                g  = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.genus_id+&quot;_genus&quot;].taxon;
          }catch(e){
                g = &#039;genus_NA&#039;
          }
          try{
                sp = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.species_id+&quot;_species&quot;].taxon;
          }
          catch(e){
                sp = &#039;species_NA&#039;
          }
          try{
                st = new_taxonomy.taxa_tree_dict_map_by_db_id_n_rank[data.strain_id+&quot;_strain&quot;].taxon;
          }
          catch(e){
                st = &#039;strain_NA&#039;
          }
          seq_tax = d+&#039;;&#039;+p+&#039;;&#039;+k+&#039;;&#039;+o+&#039;;&#039;+f+&#039;;&#039;+g+&#039;;&#039;+sp+&#039;;&#039;+st;
          if(seq_tax.substring(0, search_tax.length) === search_tax){ 
            seq_list.push({prettyseq:helpers.make_color_seq(data.seq), seq:data.seq, seq_count:data.seq_count, gast_distance:data.gast_distance, classifier:data.classifier, tax:seq_tax});          
          }
      }
      
      res.render(&#039;visuals/user_viz_data/sequences&#039;, {
                    title: &#039;Sequences&#039;,
                    ds : pjds,
                    tax : search_tax,
                    fname : seqs_filename,
                    seq_list : JSON.stringify(seq_list),
                    user: req.user, hostname: req.CONFIG.hostname,
      });
    });
  }else{
      res.render(&#039;visuals/user_viz_data/sequences&#039;, {
                    title: &#039;Sequences&#039;,
                    ds : pjds,
                    tax : search_tax,
                    fname : &#039;&#039;,
                    seq_list : &#039;Error Retrieving Sequences&#039;,
                    user: req.user, hostname: req.CONFIG.hostname,
        });
        return
  }
	
	//   });
	
});

/*
*   PARTIALS
*      These six partials all belong to the unit_selection page
*      and are shown via ajax depending on user selection in combo box
*       on that page.  AAV
*/
router.get(&#039;/partials/tax_silva119_simple&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/tax_silva119_simple&#039;, {
        doms: req.CONSTS.DOMAINS
    });
});
//
//
//

// benchmarking
// var start = process.hrtime();
//
// var elapsed_time = function(note){
//     var precision = 3; // 3 decimal places
//     var elapsed = process.hrtime(start)[1] / 1000000; // divide by a million to get nano to milli
//     console.log(process.hrtime(start)[0] + &quot; s, &quot; + elapsed.toFixed(precision) + &quot; ms - &quot; + note); // print message + time
//     start = process.hrtime(); // reset the timer
// };
router.get(&#039;/partials/load_metadata&#039;, helpers.isLoggedIn,  function(req, res) {
  var myurl = url.parse(req.url, true);
  var load = myurl.query.load  || &#039;all&#039;;   // either &#039;all&#039; or &#039;selected&#039;
  res.render(&#039;visuals/partials/load_metadata&#039;,
    { title   : &#039;metadata_table&#039;,
      load    : load
    });
});
//
//
//
router.get(&#039;/partials/tax_silva119_custom&#039;, helpers.isLoggedIn,  function(req, res) {
  res.render(&#039;visuals/partials/tax_silva119_custom&#039;,  { title   : &#039;Silva(v119) Custom Taxonomy Selection&#039;});
});
router.get(&#039;/partials/tax_rdp_simple&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/tax_rdp_simple&#039;, {
        doms: req.CONSTS.DOMAINS
    });
});
router.get(&#039;/partials/tax_gg_custom&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/tax_gg_custom&#039;,{});
});
router.get(&#039;/partials/tax_gg_simple&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/tax_gg_simple&#039;,{});
});
router.get(&#039;/partials/otus&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/otus&#039;,{});
});
router.get(&#039;/partials/med_nodes&#039;, helpers.isLoggedIn,  function(req, res) {
    res.render(&#039;visuals/partials/med_nodes&#039;,{});
});
//
// SAVE CONFIG
//
router.post(&#039;/save_config&#039;, helpers.isLoggedIn,  function(req, res) {

  console.log(&#039;req.body: save_config--&gt;&gt;&#039;);
  console.log(req.body);
  console.log(&#039;req.body: save_config&#039;);
  var timestamp = +new Date();  // millisecs since the epoch!  
  var filename = &#039;configuration-&#039; + timestamp + &#039;.json&#039;;
  // datasets/metadata...
  // metadata = META.write_mapping_file(chosen_id_name_hash, visual_post_items);
  //console.log(METADATA)
  //console.log(chosen_id_name_hash)
  var save_object = {}
  save_object.post_items = visual_post_items
  save_object.id_name_hash = chosen_id_name_hash
  console.log(save_object)

  var filename_path = path.join(req.CONFIG.USER_FILES_BASE,req.user.username,filename);
  helpers.mkdirSync(path.join(req.CONFIG.USER_FILES_BASE));  // create dir if not present
  helpers.mkdirSync(path.join(req.CONFIG.USER_FILES_BASE,req.user.username)); // create dir if not present
  //console.log(filename);
  helpers.write_to_file(filename_path, JSON.stringify(save_object));
    
  res.send(&quot;Saved as: &lt;a href=&#039;saved_elements&#039;&gt;&quot;+filename+&quot;&lt;/a&gt;&quot;);
  
  
});
// router.get(&#039;/saved_states&#039;, helpers.isLoggedIn,  function(req, res) {
//     console.log(&#039;in show_saved_configs&#039;);
//     if(req.user.username == &#039;guest&#039;){
//       req.flash(&#039;message&#039;, &quot;The &#039;guest&#039; user has no saved configs&quot;);
//       res.redirect(&#039;/user_data/your_data&#039;);
//     }else{
//       //console.log(&#039;req.body: show_saved_datasets--&gt;&gt;&#039;);
//       //console.log(req.body);
//       //console.log(&#039;req.body: show_saved_datasets&#039;);
//       var saved_configs_dir = path.join(req.CONFIG.USER_FILES_BASE,req.user.username);

//       file_info = {};
//       modify_times = [];
//       helpers.mkdirSync(saved_configs_dir);
//       fs.readdir(saved_configs_dir, function(err, files){
//           if(err){
            
//             msg = &#039;ERROR Message &#039;+err;
//             helpers.render_error_page(req,res,msg);
          
          
//           }else{
//             for (var f in files){
//                 var pts = files[f].split(&#039;-&#039;);
//                 if(pts[0] === &#039;configuration&#039;){
//                   //file_info.files.push(files[f]);
//                   stat = fs.statSync(path.join(saved_configs_dir,files[f]));
//                    file_info[stat.mtime.getTime()] = { &#039;filename&#039;:files[f], &#039;size&#039;:stat.size, &#039;mtime&#039;:stat.mtime }
//                    modify_times.push(stat.mtime.getTime());
              
//                 }
//             }   
//             modify_times.sort().reverse();
//             //console.log(JSON.stringify(file_info));
//           } 
          
//           res.render(&#039;visuals/saved_states&#039;,
//               { title: &#039;saved_configs&#039;,
               
//                 finfo: JSON.stringify(file_info),
//                 times: modify_times,
//                 message: req.flash(&#039;message&#039;),
//                 user: req.user, hostname: req.CONFIG.hostname,
//           });     
  
//       });
//     }
  
// });
router.post(&#039;/save_datasets&#039;, helpers.isLoggedIn,  function(req, res) {

  console.log(&#039;req.body: save_datasets--&gt;&gt;&#039;);
  console.log(req.body);
  console.log(&#039;req.body: save_datasets&#039;);
	
	var filename_path = path.join(req.CONFIG.USER_FILES_BASE,req.user.username,req.body.filename);
	helpers.mkdirSync(path.join(req.CONFIG.USER_FILES_BASE));  // create dir if not present
	helpers.mkdirSync(path.join(req.CONFIG.USER_FILES_BASE,req.user.username)); // create dir if not present
	//console.log(filename);
	helpers.write_to_file(filename_path,req.body.datasets);
		
	res.send(&#039;OK&#039;);
  
	
});
//
//
//
router.get(&#039;/saved_elements&#039;, helpers.isLoggedIn,  function(req, res) {
    console.log(&#039;in show_saved_datasets&#039;);
    if(req.user.username == &#039;guest&#039;){
      req.flash(&#039;message&#039;, &quot;The &#039;guest&#039; user has no saved datasets&quot;);
      res.redirect(&#039;/user_data/your_data&#039;);
    }else{
      //console.log(&#039;req.body: show_saved_datasets--&gt;&gt;&#039;);
      //console.log(req.body);
      //console.log(&#039;req.body: show_saved_datasets&#039;);
      var saved_elements_dir = path.join(req.CONFIG.USER_FILES_BASE,req.user.username);

      var file_info = {};
      var modify_times = [];
      helpers.mkdirSync(saved_elements_dir);
      fs.readdir(saved_elements_dir, function(err, files){
          if(err){
      			
    				var msg = &#039;ERROR Message &#039;+err;
    				helpers.render_error_page(req,res,msg);
    			
    			
    		  }else{
      		  for (var f in files){
      	        var pts = files[f].split(&#039;-&#039;);
      	        if(pts[0] === &#039;datasets&#039; || pts[0] === &#039;configuration&#039;){
      	          //file_info.files.push(files[f]);
      	          stat = fs.statSync(path.join(saved_elements_dir,files[f]));
      			       file_info[stat.mtime.getTime()] = { &#039;filename&#039;:files[f], &#039;size&#039;:stat.size, &#039;mtime&#039;:stat.mtime.toString() }
      			       modify_times.push(stat.mtime.getTime());
      			  
      	        }
      	    }	  
      		  modify_times.sort().reverse();
      		  //console.log(JSON.stringify(file_info));
      		} 
    		  
      		res.render(&#039;visuals/saved_elements&#039;,
      		    { title: &#039;saved_elements&#039;,
      		     
      		      finfo: JSON.stringify(file_info),
      		      times: modify_times,
      		  	  message: req.flash(&#039;message&#039;),
      		      user: req.user, hostname: req.CONFIG.hostname,
      		}); 		
	
      });
    }
	
});
//
//  R E S E T
//
router.post(&#039;/reset_ds_order&#039;, helpers.isLoggedIn,  function(req, res) {
	console.log(&#039;in reset_ds_order&#039;)
  var html = &#039;&#039;;
  html += &quot;&lt;table id=&#039;drag_table&#039; class=&#039;table table-condensed&#039; &gt;&quot;
  html += &quot;&lt;thead&gt;&lt;/thead&gt;&quot;;
  html += &quot;  &lt;tbody&gt;&quot;;
  for (var i in chosen_id_name_hash.names){
         html += &quot;&lt;tr class=&#039;tooltip_row&#039;&gt;&quot;;
         html += &quot;&lt;td class=&#039;dragHandle&#039; id=&#039;&quot;+chosen_id_name_hash.ids[i]+&quot;--&quot;+chosen_id_name_hash.names[i]+&quot;&#039;&gt; &quot;;
		     html += &quot;&lt;input type=&#039;hidden&#039; name=&#039;ds_order[]&#039; value=&#039;&quot;+chosen_id_name_hash.ids[i]+&quot;&#039;&gt;&quot;;
         html += (parseInt(i)+1).toString()+&quot; (id:&quot;+ chosen_id_name_hash.ids[i]+&quot;) - &quot;+chosen_id_name_hash.names[i];
         html += &quot;&lt;/td&gt;&quot;;
         html += &quot;   &lt;td&gt;&quot;;
         html += &quot;       &lt;a href=&#039;#&#039; onclick=&#039;move_to_the_top(&quot;+(parseInt(i)+1).toString()+&quot;,\&quot;&quot;+chosen_id_name_hash.ids[i]+&quot;--&quot;+chosen_id_name_hash.names[i]+&quot;\&quot;)&#039;&gt;^&lt;/a&gt;&quot;;
         html += &quot;   &lt;/td&gt;&quot;;
         html += &quot;&lt;/tr&gt;&quot;;
  } 
  html += &quot;&lt;/tbody&gt;&quot;;   
  html += &quot;&lt;/table&gt;&quot;;	
	res.send(html)
});
//
// A L P H A - B E T I Z E
//
router.post(&#039;/alphabetize_ds_order&#039;, helpers.isLoggedIn,  function(req, res) {
	console.log(&#039;in alphabetize_ds_order&#039;)
	var html = &#039;&#039;;
  html += &quot;&lt;table id=&#039;drag_table&#039; class=&#039;table table-condensed&#039; &gt;&quot;
  html += &quot;&lt;thead&gt;&lt;/thead&gt;&quot;;
  html += &quot;  &lt;tbody&gt;&quot;;
  var names = chosen_id_name_hash.names.slice()  // slice make an independant copy of the array
	var ids = chosen_id_name_hash.ids.slice()      // rather than copy reference
	
  names.sort()
	for (var i in names){
		     id = ids[chosen_id_name_hash.names.indexOf(names[i])]
		     html += &quot;&lt;tr class=&#039;tooltip_row&#039;&gt;&quot;;
         html += &quot;&lt;td class=&#039;dragHandle&#039; id=&#039;&quot;+ id +&quot;--&quot;+names[i]+&quot;&#039;&gt; &quot;;
		     html += &quot;&lt;input type=&#039;hidden&#039; name=&#039;ds_order[]&#039; value=&#039;&quot;+ id +&quot;&#039;&gt;&quot;;
         html += (parseInt(i)+1).toString()+&quot; (id:&quot;+ id +&quot;) - &quot;+names[i];
         html += &quot;&lt;/td&gt;&quot;;
         html += &quot;   &lt;td&gt;&quot;;
         html += &quot;       &lt;a href=&#039;#&#039; onclick=&#039;move_to_the_top(&quot;+(parseInt(i)+1).toString()+&quot;,\&quot;&quot;+id +&quot;--&quot;+names[i]+&quot;\&quot;)&#039;&gt;^&lt;/a&gt;&quot;;
         html += &quot;   &lt;/td&gt;&quot;;
         html += &quot;&lt;/tr&gt;&quot;;
  }  
  html += &quot;&lt;/tbody&gt;&quot;;  
  html += &quot;&lt;/table&gt;&quot;;	
	res.send(html)
});
//
// R E V E R S E  O R D E R
//
router.post(&#039;/reverse_ds_order&#039;, helpers.isLoggedIn,  function(req, res) {
  console.log(&#039;in reverse_ds_order&#039;)
  var ids = JSON.parse(req.body.ids);
  var html = &#039;&#039;;
  html += &quot;&lt;table id=&#039;drag_table&#039; class=&#039;table table-condensed&#039; &gt;&quot;
  html += &quot;&lt;thead&gt;&lt;/thead&gt;&quot;;
  html += &quot;  &lt;tbody&gt;&quot;;
  var names = chosen_id_name_hash.names.slice()  // slice make an independant copy of the array
  ids.reverse()
  //console.log(ids)
  for (var i in ids){
         name = names[chosen_id_name_hash.ids.indexOf(ids[i])]
         html += &quot;&lt;tr class=&#039;tooltip_row&#039;&gt;&quot;;
         html += &quot;&lt;td class=&#039;dragHandle&#039; id=&#039;&quot;+ ids[i] +&quot;--&quot;+name+&quot;&#039;&gt; &quot;;
         html += &quot;&lt;input type=&#039;hidden&#039; name=&#039;ds_order[]&#039; value=&#039;&quot;+ ids[i] +&quot;&#039;&gt;&quot;;
         html += (parseInt(i)+1).toString()+&quot; (id:&quot;+ ids[i] +&quot;) - &quot;+name;
         html += &quot;&lt;/td&gt;&quot;;
         html += &quot;   &lt;td&gt;&quot;;
         html += &quot;       &lt;a href=&#039;#&#039; onclick=&#039;move_to_the_top(&quot;+(parseInt(i)+1).toString()+&quot;,\&quot;&quot;+ids[i] +&quot;--&quot;+name+&quot;\&quot;)&#039;&gt;^&lt;/a&gt;&quot;;
         html += &quot;   &lt;/td&gt;&quot;;
         html += &quot;&lt;/tr&gt;&quot;;
  }  
  html += &quot;&lt;/tbody&gt;&quot;;  
  html += &quot;&lt;/table&gt;&quot;; 
  res.send(html)
});
//
//  C L U S T E R  D A T A S E T  O R D E R
//
router.post(&#039;/cluster_ds_order&#039;, helpers.isLoggedIn,  function(req, res) {
    console.log(&#039;in cluster_ds_order&#039;)
    var html = &#039;&#039;;
    var ts = req.body.ts;
    var metric = req.body.metric;
    var biom_file_name = ts+&#039;_count_matrix.biom&#039;;
    var biom_file = path.join(process.env.PWD,&#039;tmp&#039;,biom_file_name);
    var pwd = process.env.PWD || req.CONFIG.PROCESS_DIR;
    console.log(req.body)
    var options = {
      scriptPath : req.CONFIG.PATH_TO_VIZ_SCRIPTS,
      args :       [ &#039;-in&#039;, biom_file, &#039;-metric&#039;, metric, &#039;--function&#039;, &#039;cluster_datasets&#039;, &#039;--outdir&#039;, path.join(pwd,&#039;tmp&#039;), &#039;--prefix&#039;, ts],
    };
    console.log(options.scriptPath+&#039;/distance.py &#039;+options.args.join(&#039; &#039;));
    
    var log = fs.openSync(path.join(pwd,&#039;logs&#039;,&#039;visualization.log&#039;), &#039;a&#039;);
    
    
    var cluster_process = spawn( options.scriptPath+&#039;/distance.py&#039;, options.args, {
            env:{&#039;PATH&#039;:req.CONFIG.PATH,&#039;LD_LIBRARY_PATH&#039;:req.CONFIG.LD_LIBRARY_PATH},
            detached: true, 
            stdio: [ &#039;ignore&#039;, null, log ]
        });  // stdin, stdout, stderr
    
    
    //var heatmap_process = spawn( &#039;which&#039; , [&#039;python&#039;], {env:{&#039;PATH&#039;:envpath}});
    var output = &#039;&#039;;
    cluster_process.stdout.on(&#039;data&#039;, function (data) {
        //console.log(&#039;stdout: &#039; + data);
      // //data = data.toString().replace(/^\s+|\s+$/g, &#039;&#039;);
      // data = data.toString();

       output = data.toString();
    });
       
    cluster_process.on(&#039;close&#039;, function (code) {
      console.log(&#039;ds cluster process exited with code &#039; + code);
      var lines = output.split(/\n/)
      
      for(i in lines){
        
        if(lines[i].substring(0,7) == &#039;DS_LIST&#039;){
          tmp = lines[i].split(&#039;=&#039;)
          var ds_list = tmp[1]
          continue
        }
      }
      
      console.log(&#039;dsl&#039;,ds_list)
      //var last_line = ary[ary.length - 1];
      if(code === 0){   // SUCCESS        
        try{
            
            dataset_list = JSON.parse(ds_list);        
            
            potential_chosen_id_name_hash  = COMMON.create_new_chosen_id_name_hash(dataset_list);  
            ascii_file = ts+&#039;_&#039;+metric+&#039;_tree.txt&#039;;
            ascii_file_path = path.join(pwd,&#039;tmp&#039;,ascii_file);
            fs.readFile(ascii_file_path, &#039;utf8&#039;, function (err,ascii_tree_data) {
              if (err) {
                return console.log(err);
              }else{
                //console.log(data);
              
                html = &#039;&#039;;
                //console.log(&#039;potential_chosen_id_name_hash&#039;);        
                //console.log(potential_chosen_id_name_hash)

                html += &quot;&lt;table id=&#039;drag_table&#039; class=&#039;table table-condensed&#039; &gt;&quot;
                html += &quot;&lt;thead&gt;&lt;/thead&gt;&quot;;
                html += &quot;  &lt;tbody&gt;&quot;;
                for (var i in potential_chosen_id_name_hash.names){
                    html += &quot;&lt;tr class=&#039;tooltip_row&#039;&gt;&quot;;
                    html += &quot;&lt;td class=&#039;dragHandle&#039; id=&#039;&quot;+potential_chosen_id_name_hash.ids[i]+&quot;--&quot;+potential_chosen_id_name_hash.names[i]+&quot;&#039;&gt; &quot;;
                    html += &quot;&lt;input type=&#039;hidden&#039; name=&#039;ds_order[]&#039; value=&#039;&quot;+potential_chosen_id_name_hash.ids[i]+&quot;&#039;&gt;&quot;;
                    html += (parseInt(i)+1).toString()+&quot; (id:&quot;+ potential_chosen_id_name_hash.ids[i]+&quot;) - &quot;+potential_chosen_id_name_hash.names[i];
                    html += &quot;&lt;/td&gt;&quot;;
                    html += &quot;   &lt;td&gt;&quot;;
                    html += &quot;       &lt;a href=&#039;#&#039; onclick=&#039;move_to_the_top(&quot;+(parseInt(i)+1).toString()+&quot;,\&quot;&quot;+potential_chosen_id_name_hash.ids[i]+&quot;--&quot;+potential_chosen_id_name_hash.names[i]+&quot;\&quot;)&#039;&gt;^&lt;/a&gt;&quot;;
                    html += &quot;   &lt;/td&gt;&quot;;
                    html += &quot;&lt;/tr&gt;&quot;;
                } 
                html += &quot;&lt;/tbody&gt;&quot;;
                html += &quot;&lt;/table&gt;&quot;; 
                html += &#039;/////&lt;pre style=&quot;font-size:10px&quot;&gt;&#039;+metric+&#039;&lt;br&gt;&lt;small&gt;&#039;+ascii_tree_data+&#039;&lt;/small&gt;&lt;/pre&gt;&#039;;

                res.send(html)
              }
            });
        }
        catch(err){
          res.send(&#039;Calculation Error: &#039;+err.toString())
        }


      }else{
        //console.log(&#039;output&#039;)
        //console.log(output);
        //res.send(err);
      }      
    });   


    
});
//
//
//
router.post(&#039;/download_file&#039;, helpers.isLoggedIn,  function(req, res) {
    console.log(&#039;in download_file&#039;)
    var html = &#039;&#039;;
    var ts = req.body.ts;
    var file_type = req.body.file_type;
    if(file_type == &#039;biom&#039;){
      file_name = ts+&#039;_count_matrix.biom&#039;;  
      file_path = path.join(process.env.PWD, &#039;tmp&#039;, file_name);  
      res.setHeader(&#039;Content-Type&#039;, &#039;text&#039;);  
    }else if(file_type == &#039;tax&#039;){
      file_name = ts+&#039;_taxonomy.txt&#039;;
      file_path = path.join(process.env.PWD, &#039;tmp&#039;, file_name); 
      res.setHeader(&#039;Content-Type&#039;, &#039;text&#039;);     
    }else if(file_type == &#039;meta&#039;){
      file_name = ts+&#039;_metadata.txt&#039;;
      file_path = path.join(process.env.PWD, &#039;tmp&#039;, file_name);
      res.setHeader(&#039;Content-Type&#039;, &#039;text&#039;);      
    }else if(file_type == &#039;configuration&#039;){
      file_name = req.body.filename; 
      file_path = path.join(req.CONFIG.USER_FILES_BASE, req.user.username,  file_name);   
      res.setHeader(&#039;Content-Type&#039;, &#039;json&#039;); 
    }else{
      // ERROR
    }
    
    console.log(file_path)
    res.download(file_path); // Set disposition and send it.
});

//
//
//
router.get(&#039;/clear_filters&#039;, helpers.isLoggedIn, function(req, res) {
    //SHOW_DATA = ALL_DATASETS;
    console.log(&#039;in clear filters&#039;)
    PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, SHOW_DATA.projects);
    console.log(PROJECT_TREE_PIDS.length)
    //result = get_livesearch_html(SHOW_DATA.projects, PROJECT_INFORMATION_BY_PID, req.user);
    //res.send(&#039;tree&#039;)
    res.json(PROJECT_TREE_PIDS.length);

});
//
//
//
function filter_project_tree_for_permissions(req, obj){
  var new_project_tree_pids = []
  for( i in obj ){
      //node = PROJECT_INFORMATION_BY_PID[pid];
      //console.log(obj[i])
      pid = obj[i].pid;
      node = PROJECT_INFORMATION_BY_PID[pid];
      //console.log(node)
      if(node.public || req.user.security_level === 1 || node.permissions.length === 0 || node.permissions.indexOf(req.user.user_id) !== -1 ) { 
        //console.log(node)
        new_project_tree_pids.push(pid)
      }
  }
  //console.log(obj)
  return new_project_tree_pids
}

//
//
//
router.get(&#039;/load_portal/:portal&#039;, helpers.isLoggedIn, function(req, res) {
    var portal = req.params.portal;

    console.log(&#039;in load_portal: &#039;+portal)
    SHOW_DATA = ALL_DATASETS;
    PROJECT_TREE_OBJ = [];
    //var all_pr_dat = []
    
    PROJECT_TREE_OBJ = helpers.get_portal_projects(req,portal)
    
    console.log(&#039;PROJECT_TREE_OBJ&#039;,PROJECT_TREE_OBJ)
    PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
    console.log(&#039;PROJECT_TREE_OBJ-PIDS&#039;,PROJECT_TREE_PIDS)
    res.json(PROJECT_TREE_PIDS.length);
});
//
//  LIVESEARCH PROJECTS (substring) FILTER
//
router.get(&#039;/livesearch_projects/:substring&#039;, function(req, res) {
  var substring = req.params.substring.toUpperCase();
  var myurl = url.parse(req.url, true);  
  var portal = myurl.query.portal;
  //console.log(&#039;livesearch_projects&#039;,q)
  PROJECT_TREE_OBJ = []
  if(portal){
    var ALL_PORTAL_PROJECTS = helpers.get_portal_projects(req,portal)
    //console.log(&#039;got ALL_PORTAL_PROJECTS&#039;,ALL_PORTAL_PROJECTS)
    if(substring === &#039;----&#039;){   // revert to all portal projects
      PROJECT_TREE_OBJ = ALL_PORTAL_PROJECTS
    }else{
      ALL_PORTAL_PROJECTS.forEach(function(prj) {
        ucname = prj.name.toUpperCase();
        if(ucname.indexOf(substring) != -1){
              PROJECT_TREE_OBJ.push(prj); 
        }       
      });
    }
  }else{
      if(substring === &#039;----&#039;){  // this is value         
          PROJECT_TREE_OBJ = SHOW_DATA.projects
      }else{
          SHOW_DATA.projects.forEach(function(prj) {
            ucname = prj.name.toUpperCase();
            if(ucname.indexOf(substring) != -1){
              PROJECT_TREE_OBJ.push(prj);        
            }
          });
      }
  }
  
  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});

//
//  LIVESEARCH ENV PROJECTS FILTER
//
router.get(&#039;/livesearch_env/:envid&#039;, function(req, res) {
  var envid = req.params.envid;
  var myurl = url.parse(req.url, true);  
  var portal = myurl.query.portal;
  var info = PROJECT_INFORMATION_BY_PID;
  console.log(portal)
  console.log(envid)
  var envid_lst = []
  // if q == 40 (human) then pull all from 40-49
  if(envid === &#039;40&#039;){
    envid_lst = [40,41,42,43,44,45,46,47,48,49];
  }else{
    envid_lst = [parseInt(envid)]
  }
  PROJECT_TREE_OBJ = []
  if(portal){
      var ALL_PORTAL_PROJECTS = helpers.get_portal_projects(req,portal)
      if(envid === &#039;.....&#039;){  // revert to all portal projects
        PROJECT_TREE_OBJ = ALL_PORTAL_PROJECTS
      }else{
        ALL_PORTAL_PROJECTS.forEach(function(prj) {
            ucname = prj.name.toUpperCase();
            if( envid_lst.indexOf(parseInt(info[prj.pid].env_source_id)) != -1){
                PROJECT_TREE_OBJ.push(prj); 
            }       
        });
      }
  }else{
      if(envid === &#039;.....&#039;){          
          PROJECT_TREE_OBJ = SHOW_DATA.projects
      }else{
          
            //console.log(&#039;lst &#039;,envid_lst)
            SHOW_DATA.projects.forEach(function(prj) {
              if(envid_lst.indexOf(parseInt(info[prj.pid].env_source_id)) != -1){
                PROJECT_TREE_OBJ.push(prj);        
              }
            });
      }
  }
  
  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});
//
//  LIVESEARCH TARGET PROJECTS FILTER
//
router.get(&#039;/livesearch_target/:gene_target&#039;, function(req, res) {
  var gene_target = req.params.gene_target;
  var myurl = url.parse(req.url, true);  
  var portal = myurl.query.portal;
  //var info = PROJECT_INFORMATION_BY_PID;
  //console.log(q)
  PROJECT_TREE_OBJ = []

  if(portal){
    var ALL_PORTAL_PROJECTS = helpers.get_portal_projects(req,portal)
    if(gene_target === &#039;.....&#039;){ // revert to all portal projects
        PROJECT_TREE_OBJ = ALL_PORTAL_PROJECTS
    }else{
      ALL_PORTAL_PROJECTS.forEach(function(prj) {
          ucname = prj.name.toUpperCase();
          pparts = prj.name.split(&#039;_&#039;);
          last_el = pparts[pparts.length - 1]
          if( last_el === gene_target ){
              PROJECT_TREE_OBJ.push(prj); 
          }       
      });
    }
  }else{
      if(gene_target === &#039;.....&#039;){          
          PROJECT_TREE_OBJ = SHOW_DATA.projects
      }else{
          SHOW_DATA.projects.forEach(function(prj) {
            pparts = prj.name.split(&#039;_&#039;);
            last_el = pparts[pparts.length - 1]
            if(last_el === gene_target){
              PROJECT_TREE_OBJ.push(prj);        
            }
          });
      }
  }
  
  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});
//
//
//
//
router.get(&#039;/livesearch_portal/:portal&#039;, function(req, res) {
  console.log(&#039;in livesearch portal&#039;)
  var portal = req.params.portal;
  var myurl = url.parse(req.url, true);  
  //var portal = myurl.query.portal;
  //var info = PROJECT_INFORMATION_BY_PID;
  //console.log(q)

  PROJECT_TREE_OBJ = []
  PROJECT_TREE_OBJ = helpers.get_portal_projects(req,portal)
  //console.log(PROJECT_TREE_OBJ)

  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});
//
//
//
//
//  LIVESEARCH STATUS PROJECTS FILTER
//
router.get(&#039;/livesearch_status/:q&#039;, function(req, res) {
  console.log(&#039;in livesearch status&#039;)
  var q = req.params.q;
  var myurl = url.parse(req.url, true);  
  var portal = myurl.query.portal;
  //var info = PROJECT_INFORMATION_BY_PID;
  //console.log(q)
  PROJECT_TREE_OBJ = []
  //var all_pr_dat = []

  if(portal){
      var ALL_PORTAL_PROJECTS = helpers.get_portal_projects(req,portal)
      ALL_PORTAL_PROJECTS.forEach(function(prj) {
        
        if( PROJECT_INFORMATION_BY_PID[prj.pid].public === parseInt(q) ){
            PROJECT_TREE_OBJ.push(prj); 
        }       
      });
  }else{
      SHOW_DATA.projects.forEach(function(prj) {
          if(PROJECT_INFORMATION_BY_PID[prj.pid].public === parseInt(q)){
            PROJECT_TREE_OBJ.push(prj);        
          }
      });
  }
  
  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});
//
//
//
router.get(&#039;/set_units&#039;, function(req, res) {
  //console.log(&#039;IN SET_UNITS&#039;)

  if(req.query.hasOwnProperty(&#039;units&#039;)){
    unit_choice = req.query.units
  }else{
    unit_choice = &#039;tax_silva119_simple&#039;;
  }
  
});
//
//
//  LIVESEARCH METADATA FILTER
//
router.get(&#039;/livesearch_metadata/:q&#039;, function(req, res) {
  console.log(&#039;in livesearch metadata&#039;)
  var q = req.params.q;
  var myurl = url.parse(req.url, true);  
  var portal = myurl.query.portal;
  //var info = PROJECT_INFORMATION_BY_PID;
  //console.log(q)
  PROJECT_TREE_OBJ = []
  //var all_pr_dat = []

  if(portal){
      var ALL_PORTAL_PROJECTS = helpers.get_portal_projects(req,portal)
      PROJECT_TREE_OBJ = helpers.get_PTREE_metadata(ALL_PORTAL_PROJECTS, q)
  }else{
      PROJECT_TREE_OBJ = helpers.get_PTREE_metadata(SHOW_DATA.projects, q)
  }
  console.log(PROJECT_TREE_OBJ)
  PROJECT_TREE_PIDS = filter_project_tree_for_permissions(req, PROJECT_TREE_OBJ);
  res.json(PROJECT_TREE_PIDS.length);

});
//
//
//
router.get(&#039;/set_units&#039;, function(req, res) {
  //console.log(&#039;IN SET_UNITS&#039;)

  if(req.query.hasOwnProperty(&#039;units&#039;)){
    unit_choice = req.query.units
  }else{
    unit_choice = &#039;tax_silva119_simple&#039;;
  }
  
});
//
//
//
router.get(&#039;/tax_custom_dhtmlx&#039;, function(req, res) {
    //console.log(&#039;IN tax_custom_dhtmlx&#039;)
    var myurl = url.parse(req.url, true);
    var id = myurl.query.id
    //console.log(&#039;id=&#039;+id)
    var json = {}
    json.id = id;
    json.item = []
    if(id==0){
        // return json for collapsed tree: &#039;domain&#039; only
//         json = {&quot;id&quot;:&quot;0&quot;,&quot;item&quot;:[
//             {&quot;id&quot;:&quot;1&quot;,&quot;text&quot;:&quot;Bacteria&quot;,&quot;tooltip&quot;:&quot;domain&quot;,&quot;checked&quot;:true,&quot;child&quot;:&quot;1&quot;,&quot;item&quot;:[]},
//             {&quot;id&quot;:&quot;214&quot;,&quot;text&quot;:&quot;Archaea&quot;,&quot;tooltip&quot;:&quot;domain&quot;,&quot;checked&quot;:true,&quot;child&quot;:&quot;1&quot;,&quot;item&quot;:[]},
//             {&quot;id&quot;:&quot;338&quot;,&quot;text&quot;:&quot;Unknown&quot;,&quot;tooltip&quot;:&quot;domain&quot;,&quot;checked&quot;:true,&quot;child&quot;:&quot;1&quot;,&quot;item&quot;:[]},
//             {&quot;id&quot;:&quot;353&quot;,&quot;text&quot;:&quot;Organelle&quot;,&quot;tooltip&quot;:&quot;domain&quot;,&quot;checked&quot;:true,&quot;child&quot;:&quot;1&quot;,&quot;item&quot;:[]}
//             ]
//         }
        
        //console.log(new_taxonomy.taxa_tree_dict_map_by_rank[&quot;domain&quot;])
        for( n in new_taxonomy.taxa_tree_dict_map_by_rank[&quot;domain&quot;]){
            node = new_taxonomy.taxa_tree_dict_map_by_rank[&quot;domain&quot;][n];
            if(node.children_ids.length === 0){
                json.item.push({id:node.node_id,text:node.taxon,tooltip:node.rank,checked:true,child:0})
            }else{
                json.item.push({id:node.node_id,text:node.taxon,tooltip:node.rank,checked:true,child:1,item:[]})
            }
        }
    }else{
        
        for(n in new_taxonomy.taxa_tree_dict_map_by_id[id].children_ids){
            node_id = new_taxonomy.taxa_tree_dict_map_by_id[id].children_ids[n];
            node = new_taxonomy.taxa_tree_dict_map_by_id[node_id]
            //console.log(node)
            if(node.children_ids.length === 0){
                json.item.push({id:node.node_id,text:node.taxon,tooltip:node.rank,child:0})
            }else{
                json.item.push({id:node.node_id,text:node.taxon,tooltip:node.rank,child:1,item:[]})
            }
        }
    }
    res.json(json)
});
//
//  project_custom_dhtmlx 
//
router.get(&#039;/project_dataset_tree_dhtmlx&#039;, function(req, res) {
    console.log(&#039;IN project_dataset_tree_dhtmlx&#039;)
    var myurl = url.parse(req.url, true);
    var id = myurl.query.id
    //console.log(&#039;id=&#039;+id)
    var json = {}
    json.id = id;
    json.item = []
    //console.log(&#039;PROJECT_TREE_PIDS2&#039;,PROJECT_TREE_PIDS)
    
    if(id==0){
        //console.log(PROJECT_INFORMATION_BY_PID)
        
        for( i=0;i&lt;PROJECT_TREE_PIDS.length;i++ ){
            
            var pid = PROJECT_TREE_PIDS[i];
            var node = PROJECT_INFORMATION_BY_PID[pid];
            //console.log(&#039;node&#039;,node)
            var tt_pj_id = &#039;project-|-&#039;+node.project+&#039;-|-&#039;+node.title;
            if(node.public) {
              tt_pj_id += &#039;-|-public&#039;; 
            }else{
              tt_pj_id += &#039;-|-private&#039;; 
            }
            var pid_str = pid.toString()
            var itemtext = &quot;&lt;span id=&#039;&quot;+ tt_pj_id +&quot;&#039; class=&#039;tooltip_pjds_list&#039;&gt;&quot;+node.project+&quot;&lt;/span&gt;&quot;;
            itemtext    += &quot; &lt;a href=&#039;/projects/&quot;+pid_str+&quot;&#039;&gt;&lt;span title=&#039;profile&#039; class=&#039;glyphicon glyphicon-question-sign&#039;&gt;&lt;/span&gt;&lt;/a&gt;&quot;;
            if(node.public) {
              itemtext += &quot;&lt;small&gt; &lt;i&gt;(public)&lt;/i&gt;&lt;/small&gt;&quot;  
            }else{
                itemtext += &quot;&lt;small&gt; &lt;i&gt;(PI: &quot;+node.username +&quot;)&lt;/i&gt;&lt;/small&gt;&quot;         
            }
            
            if(Object.keys(DATA_TO_OPEN).indexOf(pid_str) &gt;= 0){
              json.item.push({id:&#039;p&#039;+pid_str, text:itemtext, checked:false, open:&#039;1&#039;,child:1, item:[]});
            }else{
              json.item.push({id:&#039;p&#039;+pid_str, text:itemtext, checked:false,  child:1, item:[]});
            }
            
                
        }
        //console.log(JSON.stringify(json, null, 4))
        
    }else{
        //console.log(JSON.stringify(ALL_DATASETS))
        var this_project = {}
        id = id.substring(1);  // id = pxx
        ALL_DATASETS.projects.forEach(function(prj) {        
          if(prj.pid == id){
            this_project = prj  
          }
        })
        var all_checked_dids = []
        if(Object.keys(DATA_TO_OPEN).length &gt; 0){
          console.log(&#039;dto&#039;);
          console.log(DATA_TO_OPEN);
          for(openpid in DATA_TO_OPEN){
            Array.prototype.push.apply(all_checked_dids, DATA_TO_OPEN[openpid])
          }
        }
        console.log(&#039;all_checked_dids&#039;)
        console.log(all_checked_dids)
        var pname = this_project.name 
        for(n in this_project.datasets){
            var did   = this_project.datasets[n].did
            //console.log(&#039;didXX&#039;,did)
            var dname = this_project.datasets[n].dname
            var ddesc = this_project.datasets[n].ddesc
            var tt_ds_id  = &#039;dataset-|-&#039;+pname+&#039;-|-&#039;+dname+&#039;-|-&#039;+ddesc;
            var itemtext = &quot;&lt;span id=&#039;&quot;+ tt_ds_id +&quot;&#039; class=&#039;tooltip_pjds_list&#039;&gt;&quot;+dname+&quot;&lt;/span&gt;&quot;;
            if(all_checked_dids.indexOf(parseInt(did)) === -1){
              json.item.push({id:did, text:itemtext, child:0})
            }else{
              json.item.push({id:did, text:itemtext, checked:&#039;1&#039;, child:0})
            }
        }
    }
    json.item.sort(function(a, b){
          return helpers.compareStrings_alpha(a.text, b.text);
    });
    //console.log(json.item)
    res.send(json)
});

module.exports = router;

/**
* F U N C T I O N S
**/

// Generally put fuction in global.js or helpers.js
//
//
//</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
